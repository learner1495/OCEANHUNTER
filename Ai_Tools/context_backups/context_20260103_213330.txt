GENERATED: 2026-01-03 21:33:30
VERSION: 2.1

########################################
0. CRITICAL WORKFLOW INSTRUCTIONS
########################################

################################################################################
#                    ğŸ”’ CRITICAL WORKFLOW & AUTOMATION RULES                   #
#                              VERSION 3.1 - FINAL#
#                           44 RULES | 9 PARTS + PART 0                        #
################################################################################

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 0: SYSTEM OVERVIEW (Ù†Ù…Ø§ÛŒ Ú©Ù„ÛŒ Ø³ÛŒØ³ØªÙ… â€” Ø§Ø¯ØºØ§Ù… Ø§Ø² AUTOMATION_GUIDE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[0.1] PURPOSE:
    Ø§ÛŒÙ† Ø³ÛŒØ³ØªÙ… Ø¨Ù‡ AI Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ø¨Ø¯ÙˆÙ† Ø¯Ø®Ø§Ù„Øª Ø¯Ø³ØªÛŒ Ú©Ø§Ø±Ø¨Ø±:
    âœ… Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ø³Ø§Ø²Ø¯ | âœ… venv Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†Ø¯ | âœ… pip install Ú©Ù†Ø¯
    âœ… ÙØ§ÛŒÙ„/ÙÙˆÙ„Ø¯Ø± Ø¨Ø³Ø§Ø²Ø¯ | âœ… Git sync Ú©Ù†Ø¯ | âœ… Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§Ø¬Ø±Ø§ Ú©Ù†Ø¯

[0.2] CORE PRINCIPLE:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  AI Ù‡Ø±Ú¯Ø² Ø§Ø² Ú©Ø§Ø±Ø¨Ø± Ù†Ø®ÙˆØ§Ù‡Ø¯ Ø¯Ø³ØªÛŒ ÙØ§ÛŒÙ„ Ø¨Ø³Ø§Ø²Ø¯ ÛŒØ§ Ú©Ø¯ Ú©Ù¾ÛŒ Ú©Ù†Ø¯.                 â”‚
    â”‚  ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÛŒØ§Øª Ø§Ø² Ø·Ø±ÛŒÙ‚ build.py Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯.                              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[0.3] BUILD.PY EXECUTION ORDER (ØªØ±ØªÛŒØ¨ Ù‚ÙÙ„â€ŒØ´Ø¯Ù‡ â€” ØºÛŒØ±Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ±):â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  STEP 1: System Checks      â†’ Internet, DNS, Python version             â”‚
    â”‚  STEP 2: venv Setup         â†’ Create .venv if not exists                â”‚
    â”‚  STEP 3: pip Install        â†’ Install from requirements.txt            â”‚
    â”‚  STEP 4: Folder Creation    â†’ Create project directories               â”‚
    â”‚  STEP 5: File Creation      â†’ Create/modify project files              â”‚
    â”‚  STEP 6: Context Generation â†’ Run context_gen.create_context_file()    â”‚
    â”‚  STEP 7: Git Init           â†’ Run setup_git.setup() (ONLY if no .git)  â”‚
    â”‚  STEP 8: Git Syncâ†’ Run setup_git.sync() (ALWAYS)            â”‚
    â”‚  STEP 9: App Launch         â†’ Run main.py via venv Python              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[0.4] FILE RESPONSIBILITIES:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ WORKFLOW.txt       â”‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ø±ÙØªØ§Ø± AI + ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø«Ø§Ø¨Øª (Ø§ÛŒÙ† ÙØ§ÛŒÙ„)â”‚
    â”‚ ARCHITECTURE.txt   â”‚ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ùˆ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø®Ø§Øµ Ù¾Ø±ÙˆÚ˜Ù‡                       â”‚
    â”‚ context_gen.py     â”‚ ØªÙˆÙ„ÛŒØ¯ LATEST_PROJECT_CONTEXT.txt                  â”‚
    â”‚ setup_git.py       â”‚ Git manager: setup() ÛŒÚ©Ø¨Ø§Ø± | sync() Ù‡Ø± Ø¨ÛŒÙ„Ø¯       â”‚
    â”‚ build.py           â”‚ Ø§Ø¬Ø±Ø§ÛŒ ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÛŒØ§Øª (Template â€” AI Ù¾Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯)        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[0.5] CONTEXT & BACKUP LOCATION:
    âœ… LATEST_PROJECT_CONTEXT.txt â†’ Ø¯Ø§Ø®Ù„ AI_Tools/
    âœ… context_backups/           â†’ Ø¯Ø§Ø®Ù„ AI_Tools/âŒ Root Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ø§ÛŒØ¯ ØªÙ…ÛŒØ² Ø¨Ù…Ø§Ù†Ø¯

[0.6] GIT CONFIGURATION (Ø«Ø§Ø¨Øª Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§Ù… Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§):

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  USERNAME:    learner1495                                               â”‚
    â”‚  EMAIL:       mostafa53548188@gmail.com                                 â”‚
    â”‚  REPO NAME:   = Ù†Ø§Ù… Ù¾ÙˆØ´Ù‡ Root Ù¾Ø±ÙˆÚ˜Ù‡ (Ø§ØªÙˆÙ…Ø§ØªÛŒÚ©)                          â”‚
    â”‚  REMOTE URL:  https://github.com/{USERNAME}/{REPO_NAME}.gitâ”‚
    â”‚  BRANCH:      main                                                      â”‚
    â”‚  AUTH METHOD: Git Credential Manager (Browser OAuth)                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 1: AUTOMATION & BUILD RULES (Ù‚ÙˆØ§Ù†ÛŒÙ† 1-6)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. AUTOMATION STRATEGY:
   All modifications via build.py. No manual file edits by user.
   build.py handles: files, folders, pip, configs.

2. DIRECTORY STRUCTURE:
   Scripts in: ProjectRoot/AI_Tools/
   Project Root = parent of AI_Tools
   Use os.path.dirname(os.path.abspath(__file__)) for paths.

3. MANDATORY CONTEXT UPDATE:
   build.py MUST import and run context_gen.create_context_file() BEFORE Git.

4. GIT AUTOMATION:
   After context update, build.py calls setup_git.sync()
   sync() handles: git add . â†’ git commit â†’ git push
   âš ï¸ build.py Ù†Ø¨Ø§ÛŒØ¯ Ù…Ø³ØªÙ‚ÛŒÙ… git command Ø§Ø¬Ø±Ø§ Ú©Ù†Ø¯ â€” ÙÙ‚Ø· Ø§Ø² setup_git Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ø¯

5. EXECUTION:
   After Git, launch main app via venv Python.

6. COMPLEXITY MANAGEMENT:
   If >3 files or >400 lines: split into phases.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 2: ANTI-HALLUCINATION RULES (Ù‚ÙˆØ§Ù†ÛŒÙ† 7-11)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

7. BEFORE ANY CODE:
   a) State understanding
   b) List files to create/modify
   c) Describe changes
   d) Ask "Proceed?" if complex

8. WHEN UNCERTAIN:
   Say "I'm not sure about X. Clarify..."
   Never guess. Never invent requirements.

9. STRICT SCOPE:
   âŒ No unrequested features
   âŒ No architecture changes without asking
   âŒ No modifying unmentioned files
   âœ… Only do what was asked

10. FILE REFERENCES:
    Only reference files in context.
    If missing: ask before creating.

11. CODE OUTPUT:
    Show only changed parts (unless full requested).
    Use markers: # === CHANGED START ===
    Specify file path. Use syntax highlighting.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 3: RESPONSE STRUCTURE (Ù‚ÙˆØ§Ù†ÛŒÙ† 12-14)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

12. EVERY RESPONSE INCLUDES:
    1. Summary of work done
    2. Files modified/created
    3. Warnings/notes
    4. Next step statement
    5. Reference code (e.g., FIX-042)

13. MULTI-PART CODE:
    Use: # â•â•â• PART 1 OF 3: [Desc] â•â•â•
    Summarize at end.

14. ERROR IN RESPONSE:
    State problem â†’ Explain why â†’ Suggest fix â†’ Ask permission

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 4: CONTEXT AWARENESS (Ù‚ÙˆØ§Ù†ÛŒÙ† 15-17)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

15. CONTEXT PRIORITY:
    1. WORKFLOW rules (first)
    2. Project structure
    3. Existing code
    4. User request

16. FRESHNESS CHECK:
    Note "GENERATED ON" timestamp.
    If >24h old, suggest refresh.

17. MISSING INFO:
    Don't proceed blind. Ask for file or suggest context_gen.py run.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 5: PROJECT-SPECIFIC (Ù‚ÙˆØ§Ù†ÛŒÙ† 18-20)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

18. PROJECT TYPE: [User fills per project]

19. TECHNOLOGIES: Python 3.10+, SQLite, [frameworks per project]

20. CRITICAL FILES (NO DELETE):
    AI_Tools/build.py
    AI_Tools/context_gen.py
    AI_Tools/WORKFLOW.txt
    AI_Tools/setup_git.py
    AI_Tools/ARCHITECTURE.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 6: COMMUNICATION (Ù‚ÙˆØ§Ù†ÛŒÙ† 21-23)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

21. LANGUAGE: Match user. Code/vars in English.

22. REFERENCE CODES: End with [TOPIC]-[NUM] (e.g., BUILD-001)

23. PROGRESS: Show step X of Y for multi-step tasks.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 7: ERROR HANDLING & SYSTEM CHECKS (Ù‚ÙˆØ§Ù†ÛŒÙ† 24-33)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

24. TRY-EXCEPT WRAPPING:
    All operations in build.py wrapped in try-except.
    Never bare except: â€” catch specific exceptions.
    Log errors with log_error("SECTION", str(e))

25. PRE-FLIGHT CHECKS (before network ops):
    25.1 Internet: ping/socket test
    25.2 DNS: resolve github.com
    25.3 Git Remote: git ls-remote --exit-code origin
    25.4 Python/Pip: version checks

26. INTERNET CHECK FUNCTION:
    Use socket with timeout=5.
    Return True/False. Log result.

27. NETWORK LIMITATION DETECTION:
    DNS Failure â†’ Log + Skip network opsFiltering â†’ Log + Warn
    Timeout â†’ Retry once + Log
    Auth Error â†’ Log + Show fix

28. GIT IDENTITY AUTO-CONFIG:
    Before commit, check user.name exists.
    If not: use values from PART 0 Section [0.6]

29. LOGGING STANDARD:
    Format: [TIMESTAMP] [LEVEL] [SECTION] Message
    Levels: INFO, WARN, ERROR, FATAL

30. GRACEFUL EXIT:
    Never crash abruptly.
    Structure: try â†’ except â†’ finally â†’ print_summary â†’ sys.exit(code)
    Codes: 0=Success, 1=Critical, 2=Unexpected, 3=Network fail

31. SUBPROCESS STANDARD:
    All external commands via run_subprocess(cmd, desc, critical=False)
    Includes: timeout, logging, error handling, return (bool, output)

32. BUILD SUMMARY REPORT:
    Print at end: System Checks status, Operations status, Errors, Warnings, Exit Code.

33. GIT AUTHENTICATION STANDARD:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  METHOD: Git Credential Manager (GCM) â€” Browser-based OAuthâ”‚
    â”‚  TRIGGER: First push OR when credentials expire                        â”‚
    â”‚  BEHAVIOR: Opens browser â†’ User logs in â†’ Token cached automatically   â”‚
    â”‚  FALLBACK: If no browser, show manual token instructionsâ”‚
    â”‚  CONFIG: credential.helper=manager (Windows) | manager-core (Linux)    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    âš ï¸ Ù‡Ø±Ú¯Ø² Ø§Ø² Personal Access Token Ø¯Ø± Ú©Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ø´ÙˆØ¯
    âš ï¸ Ù‡Ø±Ú¯Ø² password Ø¯Ø± plaintext Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´ÙˆØ¯

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 8: DOCUMENTATION REFERENCE RULES (Ù‚ÙˆØ§Ù†ÛŒÙ† 34-38)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

34. MANDATORY DOC CHECK:
    Before implementing any feature, AI MUST check if official docs exist.
    Never code from memory alone for libraries/APIs.

35. UNKNOWN LIBRARY HANDLING:
    If unfamiliar with a library:
    âŒ Do NOT guess syntax
    âœ… Ask user for docs link OR
    âœ… State: "I need to verify X library docs before proceeding"

36. API IMPLEMENTATION:
    For any external API (exchange, service, etc.):
    - Request official API docs
    - Verify endpoints, parameters, auth method
    - Never assume API structure

37. VERSION SENSITIVITY:
    Libraries change between versions.
    If version not specified: ask or state assumption clearly.

38. DOCUMENTATION PRIORITY:
    1. Official docs (highest)
    2. Context code examples
    3. User description
    4. AI knowledge (lowest â€” verify first)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 9: CODE COMPACTNESS RULES (Ù‚ÙˆØ§Ù†ÛŒÙ† 39-41)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

39. NAMING CONVENTION:
    âœ… Concise but readable names (e.g., get_bal not get_user_balance_from_api)
    âœ… Single-letter only for loops (i, j, k)
    âœ… Descriptive for functions/classes

40. CODE DENSITY:
    âœ… Combine related operations on single line where readable
    âœ… Use list/dict comprehensions where appropriate
    âœ… Minimal vertical whitespace (no triple blank lines)
    âœ… Remove excess comments (no "# this adds two numbers")âŒ No decorative ASCII art in production code
    âŒ No empty placeholder sections
    âŒ No repeated code â€” extract to functions

41. LINE EFFICIENCY:
    âœ… One-liner if simple: if x: do_y()
    âœ… Ternary where clear: result = a if cond else b
    âŒ No multi-line when one works
    âŒ No verbose logging for obvious operations
    Target: Maximum clarity with minimum lines.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 10: FINAL AUTHORITY (Ù‚ÙˆØ§Ù†ÛŒÙ† 42-44)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

42. WORKFLOW SUPREMACY:
    This file (WORKFLOW.txt) is the FINAL AUTHORITY for AI behavior.
    If conflict with other files: WORKFLOW wins.

43. ARCHITECTURE RESPECT:
    ARCHITECTURE.txt defines project-specific logic.
    AI must follow it but cannot modify without explicit permission.

44. SINGLE RESPONSIBILITY:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ build.py           â”‚ Only executor â€” runs all operations             â”‚
    â”‚ context_gen.py     â”‚ Only context writer â€” generates context file    â”‚
    â”‚ setup_git.py       â”‚ Git manager â€” setup() once + sync() every build â”‚
    â”‚ WORKFLOW.txt       â”‚ Only behavior authority â€” AI rulesâ”‚
    â”‚ ARCHITECTURE.txt   â”‚ Only architecture authority â€” project logic     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    âš ï¸ Ù‡ÛŒÚ† ÙØ§ÛŒÙ„ÛŒ Ù†Ø¨Ø§ÛŒØ¯ ÙˆØ¸ÛŒÙÙ‡ ÙØ§ÛŒÙ„ Ø¯ÛŒÚ¯Ø± Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡Ø¯

################################################################################
#END OF WORKFLOW.txt                               #
#VERSION 3.1 | 44 RULES | 10 PARTS                       #
################################################################################


[âœ… Loaded: WORKFLOW.txt]

########################################
1. PROJECT ARCHITECTURE
########################################

################################################################################
#                    OCEAN HUNTER V10.8.2 â€” COMPLETE SECURE ARCHITECTURE       #
#           SPOT SWING TRADING | 5 ALTCOINS â†’ BTC + PAXG ACCUMULATION          #
#                     Date: 1404/10/09 | 2025-12-30                            #
#                                                                              #
#   STATUS: FINAL & LOCKED | CAPITAL: PERCENTAGE-BASED | SECURITY: MAXIMUM    #
#   REFERENCE: REF-ARCH-V10.8.2-FINAL-LOCK-610                                 #
################################################################################

================================================================================
SECTION 1 â€” CAPITAL ALLOCATION & ASSET ROLES
================================================================================

[1.1] Capital Model: PERCENTAGE-BASED (Scalable)
    - Minimum Required: 500 USDT
    - No Maximum Limit
    - All calculations use percentages, not fixed amounts

[1.2] Asset Allocation Table:

    +------------+---------+---------------------------------------------+
    | Asset      | Percent | Role                                        |
    +------------+---------+---------------------------------------------+
    | SOL        | 25%     | Primary Swing Target                        |
    | BNB        | 20%     | Secondary Swing Target                      |
    | XRP        | 15%     | Tertiary Swing Target                       |
    | AVAX       | 10%     | Opportunity Target                          |
    | LINK       | 10%     | Opportunity Target                          |
    | USDT       | 10%     | Operating Reserve (DCA Fuel)                |
    | BTC        | 5%      | Growth Vault (Profit Destination)           |
    | PAXG       | 5%      | Smart Vault (Safe Haven + Refuel)           |
    +------------+---------+---------------------------------------------+
    | TOTAL      | 100%    |                                             |
    +------------+---------+---------------------------------------------+

[1.3] Golden Flow of Capital:

    USDT --> Buy Altcoin --> Sell with Profit --> Profit Router --> BTC/PAXG
                          --> Principal returns to USDT Pool

[1.4] Core Safety Rules:

    [X] NO STOP-LOSS (DCA replaces cutting losses)
    [X] NO LEVERAGE (Spot only)
    [X] NO ETH (Focus on faster alts)
    [V] PAXG = Last line of defense (Emergency Refuel)

================================================================================
SECTION 2 â€” STRATEGY LOGIC: SMART SNIPER
================================================================================

[2.1] Timeframes:
    - Analysis: M15 (candle close)
    - Safety Checks: Real-time / 60s

[2.2] Entry Logic (Score >= 70 to Enter):

    +--------------------+------------------------------------+--------+
    | Factor             | Condition                          | Points |
    +--------------------+------------------------------------+--------+
    | Technical          | RSI(14) < 35 AND Price < BB_Lower  | 35     |
    | Order Book (OBI)   | Bid Volume > Ask Volume (Top 20)   | 15     |
    | Volume Spike       | Volume > 1.5 x SMA(20)             | 25     |
    | Momentum           | Green Candle (Close > Open)        | 25     |
    +--------------------+------------------------------------+--------+
    | TOTAL POSSIBLE     |                                    | 100    |
    +--------------------+------------------------------------+--------+

    NOTE: OBI weight reduced to 15 (was 30) due to Nobitex manipulation risk

[2.3] Exit Logic:
    - Take Profit: 1.5% - 3% (Dynamic based on momentum)
    - Trailing Stop: Activates after +1% profit

[2.4] DCA Layers (If Position Goes Against):

    +-------+---------------+----------------+-----------------+
    | Layer | Trigger       | Add Amount     | New Avg Target  |
    +-------+---------------+----------------+-----------------+
    | L1    | -3% from Avg  | +50% Position  | Reduce by ~1.5% |
    | L2    | -6% from Avg  | +75% Position  | Reduce by ~2.5% |
    | L3    | -10% from Avg | +100% Position | Reduce by ~4%   |
    +-------+---------------+----------------+-----------------+

[2.5] NOBITEX API SPECIFICATIONS:

    [2.5.1] Rate Limits:
        - Private API: 30 requests/minute (HARD LIMIT)
        - Implementation: Use 25 req/min with 2.5s spacing

    [2.5.2] Order Constraints:
        - Minimum Order: 10 USDT (Use 12 USDT buffer)
        - Order Types: "limit" and "market" ONLY
        - Precision: Fetch dynamically from GET /v2/options

    [2.5.3] Fee Structure:
        - Taker Fee: 0.35%
        - Maker Fee: 0.25%
        - Use 0.35% in all calculations (worst case)

    [2.5.4] Key Endpoints:

        +-----------------------------+----------------------------------+
        | Endpoint                    | Purpose                          |
        +-----------------------------+----------------------------------+
        | GET /v2/wallets             | Fetch all balances               |
        | GET /v2/orderbook/{symbol}  | Order book for OBI calculation   |
        | GET /v2/trades/{symbol}     | Recent trades                    |
        | POST /market/orders/add     | Place new order                  |
        | POST /market/orders/cancel  | Cancel existing order            |
        | GET /v2/options             | Trading pairs info (precision)   |
        | GET /market/udf/history     | OHLCV candle data                |
        +-----------------------------+----------------------------------+

    [2.5.5] Authentication:
        - Header: Authorization: Token {API_KEY}

[2.6] POSITION LIMITS & QUEUE SYSTEM:

    [2.6.1] Concurrent Position Limit:
        MAX_CONCURRENT_POSITIONS = 3

    [2.6.2] Queue Management:
        - Signals scoring >= 70 but blocked â†’ Add to WAITING_QUEUE
        - Queue stores: {symbol, score, timestamp, price_at_signal}
        - Queue Expiry: 4 HOURS (signal becomes stale)
        - Max Queue Size: 5 signals

    [2.6.3] Queue Processing:
        WHEN position closes:
            CHECK WAITING_QUEUE
            FOR each queued signal (oldest first):
                IF not expired AND current_price <= price_at_signal * 1.01:
                    RE-EVALUATE score
                    IF score >= 70: EXECUTE
                ELSE:
                    DISCARD signal

    [2.6.4] Overexposure Protection:
        IF all 3 slots filled AND new signal score >= 85:
            LOG "High-conviction signal blocked"
            ALERT via Telegram
            ADD to priority queue

[2.7] BTC TREND FILTER (Entry Gate):

    BEFORE any new entry:
        CHECK BTC_HEALTH (from Section 3.1)
        IF BTC_HEALTH == "WEAK":
            BLOCK new entries completely
            LOG "Entry blocked: BTC in WEAK state"
            ALERT via Telegram
        IF BTC_HEALTH == "NEUTRAL" or "STRONG":
            ALLOW entry evaluation

[2.8] ORDER EXECUTION STRATEGY:

    [2.8.1] Primary Method: LIMIT ORDER
        - Price: Current price + 0.1% (for BUY)
        - Price: Current price - 0.1% (for SELL)
        - Timeout: 30 seconds

    [2.8.2] Fallback Method: MARKET ORDER
        IF Limit order not filled in 30 seconds:
            CANCEL limit order
            PLACE market order
            LOG "Fallback to market order"

    [2.8.3] Benefits:
        - Reduced slippage
        - Lower fees (Maker vs Taker)
        - Protection against price manipulation

================================================================================
SECTION 3 â€” PROFIT ROUTER V2.0 (DYNAMIC BTC/PAXG SPLIT)
================================================================================

[3.1] BTC Health Assessment (1H Timeframe):
    - Indicators: RSI(14), EMA(50), MACD(12,26,9)

    BTC_STRONG  = RSI > 60 AND Price > EMA(50) AND MACD > 0
    BTC_WEAK    = RSI < 40 AND Price < EMA(50) AND MACD < 0
    BTC_NEUTRAL = Everything else

[3.2] Profit Distribution Rules:

    +------------------+-----------------+-----------------+
    | BTC State        | To BTC Vault    | To PAXG Vault   |
    +------------------+-----------------+-----------------+
    | STRONG           | 80%             | 20%             |
    | NEUTRAL          | 50%             | 50%             |
    | WEAK             | 20%             | 80%             |
    +------------------+-----------------+-----------------+

[3.3] Profit Flow Example (100 USDT profit, NEUTRAL state):
    â†’ 50 USDT â†’ Buy BTC â†’ BTC Vault
    â†’ 50 USDT â†’ Buy PAXG â†’ PAXG Vault

================================================================================
SECTION 4 â€” EMERGENCY REFUEL PROTOCOL (PAXG â†’ USDT)
================================================================================

[4.1] Activation Conditions (ALL must be true):
    - DCA Layer 3 is active
    - USDT Pool < 20% of allocated slot capital
    - PAXG position is in PROFIT
    - Global Stop is NOT active

[4.2] Execution Limits:
    - Maximum sell: 50% of PAXG holdings
    - Cooldown: 24 hours between refuels

[4.3] WAIT MODE:
    IF PAXG is at loss when needed:
        PAUSE DCA execution
        WAIT for PAXG recovery
        ALERT "Waiting for PAXG profit to refuel"

[4.4] Refuel Flow:
    PAXG (profit) â†’ Sell 50% â†’ USDT â†’ Fund DCA Layer 3

================================================================================
SECTION 5 â€” WATCHDOG BELLE (System Health Monitor)
================================================================================

[5.1] Check Interval: Every 60 seconds

[5.2] Health Checks:

    +-----+---------------------------+------------------+------------------+
    | #   | Check                     | Warning          | Critical         |
    +-----+---------------------------+------------------+------------------+
    | 1   | API Response Time         | > 5 seconds      | > 10 seconds     |
    | 2   | Balance Sync              | > 1% mismatch    | > 5% mismatch    |
    | 3   | Position Drift            | > 2% from state  | > 5% from state  |
    | 4   | Memory Usage              | > 70%            | > 90%            |
    | 5   | Open Order Age            | > 30 minutes     | > 60 minutes     |
    | 6   | Last Successful Trade     | > 24 hours       | > 72 hours       |
    +-----+---------------------------+------------------+------------------+

[5.3] Actions:
    - Warning: Log + Continue
    - Critical: Log + Alert + Consider HALT

[5.4] External Heartbeat:
    - Send Telegram message every 30 MINUTES
    - Message includes: Status, Open Positions, USDT Balance, BTC Health
    - If no heartbeat received â†’ System may be down

================================================================================
SECTION 6 â€” TELEGRAM INTEGRATION
================================================================================

[6.1] Alert Levels:

    +----------+-------------------+----------------------------------------+
    | Level    | Emoji             | Use Case                               |
    +----------+-------------------+----------------------------------------+
    | INFO     | â„¹ï¸                | Trade opened, closed, status updates   |
    | WARNING  | âš ï¸                | DCA triggered, queue full, anomaly     |
    | CRITICAL | ğŸš¨                | Global stop, kill switch, system halt  |
    | SUCCESS  | âœ…                | Profitable trade, vault deposit        |
    +----------+-------------------+----------------------------------------+

[6.2] Commands:

    /status     â†’ Current positions, balances, mode
    /stop       â†’ Activate Global Stop
    /restart    â†’ Begin recovery protocol
    /report     â†’ Daily summary
    /mode       â†’ Show current trading mode
    /queue      â†’ Show waiting queue status
    /health     â†’ Show BTC health state

[6.3] Connection:
    - Use SOCKS5 proxy (127.0.0.1:1080) for Iran
    - Retry logic: 3 attempts with 5s delay
    - Fallback: Log locally if Telegram fails

[6.4] Security:
    - WHITELIST_CHAT_IDS: Only your chat ID allowed
    - Rate limit commands: 1 per 5 seconds
    - Critical commands require /confirm within 30 seconds

================================================================================
SECTION 7 â€” DATA FLOW DIAGRAM
================================================================================

    +------------------+
    |   Nobitex API    |
    +--------+---------+
             |
             v
    +--------+---------+
    |   Rate Limiter   | (25 req/min, 2.5s spacing)
    +--------+---------+
             |
             v
    +--------+---------+
    |  Data Processor  | (Candles, Order Book, Balances)
    +--------+---------+
             |
    +--------+--------+--------+
    |        |        |        |
    v        v        v        v
+-------+ +------+ +------+ +--------+
|Spread | |Wick  | |Volume| |Indicators|
|Filter | |Filter| |Check | |(RSI,BB) |
+---+---+ +--+---+ +--+---+ +----+----+
    |        |        |          |
    +--------+--------+----------+
             |
             v
    +--------+---------+
    |  Strategy Engine | (Score calculation)
    +--------+---------+
             |
             v
    +--------+---------+
    | Position Manager | (Max 3 + Queue)
    +--------+---------+
             |
             v
    +--------+---------+
    |  Order Executor  | (Limit first, Market fallback)
    +--------+---------+
             |
             v
    +--------+---------+
    |  Profit Router   | (BTC/PAXG split)
    +--------+---------+
             |
             v
    +--------+---------+
    |  State Manager   | (state.json + backup)
    +--------+---------+
             |
             v
    +--------+---------+
    |    Telegram      | (Alerts + Heartbeat)
    +------------------+
================================================================================
SECTION 8 â€” DIRECTORY STRUCTURE
================================================================================

OCEAN_HUNTER/
â”œâ”€â”€ main.py                     # Entry point + main loop
â”œâ”€â”€ config.py                   # All parameters & thresholds
â”œâ”€â”€ requirements.txt            # Python dependencies
â”œâ”€â”€ state.json                  # Persistent state (positions, balances)
â”œâ”€â”€ trades.xlsx                 # Trade history log
â”œâ”€â”€ .env                        # API keys (NEVER commit!)
â”œâ”€â”€ .gitignore                  # Git ignore rules
â”‚
â”œâ”€â”€ Ai_Tools/                   # AI Development Toolkit
â”‚   â”œâ”€â”€ setup_git.py            # Git repository initializer
â”‚   â”œâ”€â”€ build.py                # Auto-build script
â”‚   â”œâ”€â”€ context_gen.py          # Project context generator
â”‚   â”œâ”€â”€ WORKFLOW.txt            # Automation rules
â”‚   â””â”€â”€ ARCHITECTURE.txt        # This document (V10.8.2)
â”‚
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ engine.py           # Main trade cycle manager
â”‚   â”‚   â”œâ”€â”€ config_loader.py    # Load config & .env
â”‚   â”‚   â”œâ”€â”€ rate_limiter.py     # API rate limiting (25 req/min)
â”‚   â”‚   â”œâ”€â”€ state_manager.py    # Read/Write state.json + backup
â”‚   â”‚   â””â”€â”€ safety_manager.py   # Kill switch, mode gates, drawdown
â”‚   â”‚
â”‚   â”œâ”€â”€ network/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ nobitex.py          # Exchange API wrapper
â”‚   â”‚   â””â”€â”€ telegram.py         # Alerts with SOCKS5 proxy
â”‚   â”‚
â”‚   â”œâ”€â”€ analysis/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ indicators.py       # RSI, EMA, BB, MACD, ATR
â”‚   â”‚   â”œâ”€â”€ orderflow.py        # OBI calculation
â”‚   â”‚   â””â”€â”€ btc_health.py       # BTC state assessment
â”‚   â”‚
â”‚   â”œâ”€â”€ trading/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ strategy.py         # Entry/Exit scoring
â”‚   â”‚   â”œâ”€â”€ dca_manager.py      # DCA layers + WAIT MODE
â”‚   â”‚   â”œâ”€â”€ profit_router.py    # BTC/PAXG distribution
â”‚   â”‚   â”œâ”€â”€ position_manager.py # Max 3 positions + Queue [NEW V10.8]
â”‚   â”‚   â””â”€â”€ refuel.py           # Emergency PAXG liquidation
â”‚   â”‚
â”‚   â”œâ”€â”€ security/               # [NEW V10.8.2]
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ spread_filter.py    # Abnormal spread detection
â”‚   â”‚   â”œâ”€â”€ wick_filter.py      # Fake candle neutralizer
â”‚   â”‚   â”œâ”€â”€ volume_sanity.py    # Wash trade detection
â”‚   â”‚   â””â”€â”€ order_lock.py       # Race condition prevention
â”‚   â”‚
â”‚   â””â”€â”€ watchdog/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ belle.py            # 60s health monitor + 30min heartbeat
â”‚
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ candles_cache/          # Cached OHLCV data
â”‚   â”œâ”€â”€ state_backups/          # Rolling 10 backups [NEW V10.8.2]
â”‚   â””â”€â”€ logs/                   # Daily log files
â”‚
â””â”€â”€ context_backups/            # Auto-generated context snapshots

================================================================================
SECTION 9 â€” REPORTING (trades.xlsx)
================================================================================

[9.1] Trade Log Columns:

    +-----+-------------------+------------------------------------------------+
    | #   | Column Name       | Description                                    |
    +-----+-------------------+------------------------------------------------+
    | 1   | trade_id          | Unique identifier (UUID)                       |
    | 2   | timestamp         | Trade execution time                           |
    | 3   | symbol            | Trading pair (e.g., SOLUSDT)                   |
    | 4   | side              | BUY or SELL                                    |
    | 5   | entry_price       | Average entry price                            |
    | 6   | exit_price        | Exit price (if closed)                         |
    | 7   | quantity          | Amount traded                                  |
    | 8   | pnl_usdt          | Profit/Loss in USDT                            |
    | 9   | pnl_percent       | Profit/Loss percentage                         |
    | 10  | dca_layer         | DCA level used (0-3)                           |
    | 11  | profit_destination| Where profit went (BTC/PAXG/BOTH)              |
    | 12  | btc_health_state  | BTC state at profit time                       |
    | 13  | paxg_action       | HOLD/REFUEL/NONE                               |
    | 14  | emergency_refuel  | TRUE/FALSE (was PAXG used for rescue)          |
    | 15  | fees_paid         | Total fees in USDT                             |
    | 16  | duration_minutes  | Time from entry to exit                        |
    | 17  | score_at_entry    | Strategy score when entered                    |
    | 18  | queue_wait_time   | Minutes waited in queue (0 if immediate) [NEW] |
    | 19  | security_flags    | Any filters triggered (spread/wick/volume)[NEW]|
    | 20  | notes             | Auto-generated trade notes                     |
    +-----+-------------------+------------------------------------------------+

[9.2] Daily Summary Sheet:

    - Total trades executed
    - Win rate percentage
    - Net PnL (USDT)
    - BTC vault growth
    - PAXG vault growth
    - Max drawdown reached
    - API calls made
    - Queue utilization (signals queued vs executed) [NEW V10.8]
    - Security blocks count (spread/wick/volume) [NEW V10.8.2]

================================================================================
SECTION 10 â€” GLOBAL STOP PROTOCOL
================================================================================

[10.1] Activation Conditions (ANY triggers STOP):

    +-----+----------------------------------+----------------------------------+
    | #   | Condition                        | Detection Method                 |
    +-----+----------------------------------+----------------------------------+
    | 1   | BTC drops > 8% in 4 hours        | Price monitoring (1H candles)    |
    | 2   | Portfolio drawdown > 15%         | Real-time balance check          |
    | 3   | API failure > 60 seconds         | Health check timeout             |
    | 4   | Manual STOP command              | Telegram /stop command           |
    | 5   | Balance mismatch > 5%            | Local vs Exchange comparison     |
    | 6   | State file corruption            | Checksum validation [NEW V10.8.2]|
    +-----+----------------------------------+----------------------------------+

[10.2] STOP Actions:

    1. Cancel ALL open orders immediately
    2. Set system state to HALTED
    3. Send CRITICAL alert to Telegram
    4. Log all current positions and balances
    5. Clear WAITING_QUEUE [NEW V10.8]
    6. Require manual restart with confirmation

[10.3] Recovery Protocol:

    1. User sends /restart command
    2. System performs full health check
    3. Compares state.json with exchange data
    4. Validates state.json checksum [NEW V10.8.2]
    5. If mismatch found â†’ require manual resolution
    6. If clean â†’ resume in EXIT_ONLY mode for 1 hour
    7. After 1 hour with no issues â†’ resume NORMAL mode

================================================================================
SECTION 11 â€” SECURITY PROTOCOLS (HARDENED)
================================================================================

[11.1] Trading Mode Gates (MANDATORY PROGRESSION):

    +------------+------------------+-------------------------------------------+
    | Mode       | Duration         | Restrictions                              |
    +------------+------------------+-------------------------------------------+
    | PAPER      | Min 72 hours     | NO real orders, simulation only           |
    | LIVE_TEST  | Min 7 days       | Max 50 USDT total exposure                |
    | LIVE_FULL  | After approval   | Full capital with all safety checks       |
    +------------+------------------+-------------------------------------------+

    Mode Transition Rules:
    - PAPER â†’ LIVE_TEST: Requires 72h runtime + manual approval
    - LIVE_TEST â†’ LIVE_FULL: Requires 7 days + positive PnL + manual approval
    - Any mode can go back to PAPER instantly

[11.2] Hardware Kill Switch:

    Activation Triggers:
    - Internet disconnection > 30 seconds
    - API unresponsive > 60 seconds
    - System memory > 90%
    - Unexpected exception in main loop

    Kill Actions:
    - Immediately terminate all processes
    - Do NOT attempt order cancellation (may fail)
    - Write emergency state dump to disk
    - Send offline alert via backup channel (if possible)

[11.3] Request Rate Limiter:

    Configuration:
    - Hard limit: 25 requests per minute (below Nobitex 30)
    - Minimum spacing: 2.5 seconds between requests
    - Queue overflow action: REJECT and ALERT

    Implementation:
    - Token bucket algorithm
    - Separate queues for: Orders, Balance, Market Data
    - Priority: Orders > Balance > Market Data

[11.4] Balance Sanity Checker:

    Pre-Order Verification:
    1. Fetch fresh balance from exchange
    2. Compare with local state.json
    3. If difference > 5% â†’ HALT + ALERT
    4. If difference 1-5% â†’ WARNING + Continue
    5. If difference < 1% â†’ OK

    Post-Order Verification:
    1. Wait 3 seconds after order
    2. Fetch updated balance
    3. Verify expected change occurred
    4. Log discrepancy if any

[11.5] Maximum Drawdown Protection:

    Threshold: 15% of initial portfolio value

    Monitoring:
    - Check every 60 seconds (via Watchdog)
    - Calculate: (Initial_Value - Current_Value) / Initial_Value

    Action on Breach:
    1. Immediate GLOBAL STOP
    2. Cancel all open orders
    3. Send CRITICAL alert with full report
    4. Require manual intervention to restart
    5. Log incident with timestamp and portfolio snapshot

[11.6] API Key Security:

    Storage:
    - .env file with 600 permissions (owner read/write only)
    - Never logged, never in error messages
    - Never committed to git (.gitignore enforced)

    Runtime:
    - Load once at startup
    - Store in memory only
    - Clear on shutdown

    Exchange Panel Settings [NEW V10.8.2]:
    - [X] IP Whitelist: SERVER_IP_ONLY
    - [X] Permissions: Trade + Read
    - [ ] Withdrawal: DISABLED (CRITICAL!)

[11.7] Audit Trail:

    All Actions Logged:
    - Every API request with timestamp
    - Every order placed/cancelled
    - Every state change
    - Every alert sent
    - Every mode transition
    - Every security filter trigger [NEW V10.8.2]

    Log Retention:
    - Daily rotation
    - 30 days local storage
    - Critical events: permanent

[11.8] Anti-Manipulation Filters [NEW V10.8.2]:

    [11.8.1] Spread Filter:
        MAX_SPREAD_PERCENT = 0.005 (0.5%)
        
        Logic:
            spread = (best_ask - best_bid) / best_bid
            IF spread > MAX_SPREAD_PERCENT:
                BLOCK entry
                LOG "Abnormal spread detected"
                ALERT (WARNING)

    [11.8.2] Wick Filter:
        Logic:
            candle_body = |close - open|
            candle_wick = (high - low) - candle_body
            IF candle_wick > 3 Ã— candle_body:
                IGNORE current candle
                USE previous candle for indicators
                LOG "Abnormal wick ignored"

    [11.8.3] Volume Sanity Check:
        Logic:
            avg_volume = SMA(volume, 20)
            IF current_volume > 10 Ã— avg_volume:
                FLAG as SUSPICIOUS
                REDUCE position size by 50%
                ALERT (INFO)

    [11.8.4] Order Duplication Lock:
        ORDER_LOCK = GLOBAL MUTEX
        MIN_ORDER_INTERVAL = 5 seconds
        
        Logic:
            BEFORE placing order:
                ACQUIRE ORDER_LOCK
                IF last_order_time < 5 seconds:
                    CANCEL placement
                    LOG "Duplicate order prevented"
            AFTER placement:
                RELEASE ORDER_LOCK

    [11.8.5] State File Protection:
        - Backup state.json every 5 minutes
        - Keep last 10 backups (rolling)
        - Validate checksum on load
        - AUTO-RESTORE if corruption detected
        - Start in EXIT_ONLY mode after restore

    [11.8.6] Security Boundary Principle:
        Security filters NEVER:
            - Modify strategy logic
            - Modify scoring weights
            - Force entries
        
        They ONLY:
            - BLOCK execution
            - REDUCE size
            - DELAY execution
        
        Strategy purity is preserved.

================================================================================
SECTION 12 â€” CONFIGURATION REFERENCE (config.py)
================================================================================

[12.1] Capital Settings:

    # PERCENTAGE-BASED (V10.8+)
    MIN_CAPITAL_USDT = 500
    
    ALLOCATION = {
        "SOL": 0.25,
        "BNB": 0.20,
        "XRP": 0.15,
        "AVAX": 0.10,
        "LINK": 0.10,
        "USDT": 0.10,
        "BTC": 0.05,
        "PAXG": 0.05
    }

[12.2] Trading Parameters:

    MIN_ORDER_USDT = 12
    ENTRY_SCORE_THRESHOLD = 70
    TAKE_PROFIT_MIN = 0.015
    TAKE_PROFIT_MAX = 0.030
    TRAILING_ACTIVATION = 0.01
    
    # Order Execution (V10.8.1+)
    ORDER_TYPE_PRIMARY = "limit"
    LIMIT_ORDER_OFFSET = 0.001  # 0.1%
    LIMIT_ORDER_TIMEOUT = 30   # seconds
    ORDER_TYPE_FALLBACK = "market"

[12.3] Position Management (V10.8+):

    MAX_CONCURRENT_POSITIONS = 3
    QUEUE_MAX_SIZE = 5
    QUEUE_EXPIRY_HOURS = 4
    QUEUE_PRICE_TOLERANCE = 0.01  # 1%

[12.4] Entry Scoring Weights (V10.8.1+):

    SCORE_WEIGHTS = {
        "technical": 35,    # RSI + BB
        "obi": 15,          # Order Book Imbalance (reduced)
        "volume": 25,       # Volume spike
        "momentum": 25      # Green candle
    }

[12.5] DCA Settings:

    DCA_LAYERS = {
        1: {"trigger": -0.03, "add_percent": 0.50},
        2: {"trigger": -0.06, "add_percent": 0.75},
        3: {"trigger": -0.10, "add_percent": 1.00}
    }

[12.6] Safety Settings:

    MAX_DRAWDOWN_PERCENT = 0.15
    API_TIMEOUT_SECONDS = 10
    KILL_SWITCH_TIMEOUT = 60
    BALANCE_MISMATCH_HALT = 0.05
    BALANCE_MISMATCH_WARN = 0.01


[12.7] Rate Limiting:

    REQUESTS_PER_MINUTE = 25
    MIN_REQUEST_SPACING = 2.5  # seconds

[12.8] Profit Router:

    BTC_HEALTH_THRESHOLDS = {
        "STRONG": {"rsi_min": 60, "above_ema": True, "macd_positive": True},
        "WEAK": {"rsi_max": 40, "below_ema": True, "macd_negative": True}
    }
    
    PROFIT_SPLIT = {
        "STRONG": {"btc": 0.80, "paxg": 0.20},
        "NEUTRAL": {"btc": 0.50, "paxg": 0.50},
        "WEAK": {"btc": 0.20, "paxg": 0.80}
    }

[12.9] Emergency Refuel:

    PAXG_MAX_SELL_PERCENT = 0.50
    REFUEL_COOLDOWN_HOURS = 24
    USDT_LOW_THRESHOLD = 0.20  # 20% of slot capital

[12.10] Telegram:

    TELEGRAM_BOT_TOKEN = "from .env"
    TELEGRAM_CHAT_ID = "from .env"
    TELEGRAM_PROXY_HOST = "127.0.0.1"
    TELEGRAM_PROXY_PORT = 1080
    HEARTBEAT_INTERVAL_MINUTES = 30  # [NEW V10.8]

[12.11] Nobitex:

    NOBITEX_API_KEY = "from .env"
    NOBITEX_BASE_URL = "https://api.nobitex.ir"
    TAKER_FEE = 0.0035
    MAKER_FEE = 0.0025

[12.12] Security Filters [NEW V10.8.2]:

    MAX_SPREAD_PERCENT = 0.005        # 0.5%
    WICK_BODY_RATIO_MAX = 3.0         # wick > 3x body = ignore
    VOLUME_SPIKE_MULTIPLIER = 10      # > 10x avg = suspicious
    MIN_ORDER_INTERVAL_SECONDS = 5    # anti-duplicate
    STATE_BACKUP_INTERVAL_MINUTES = 5
    STATE_BACKUP_KEEP_COUNT = 10

================================================================================
SECTION 13 â€” WATCHDOG MODULE (BELLE)
================================================================================

[13.1] Core Responsibilities:

    +-----+----------------------------------+----------------------------------+
    | #   | Task                             | Interval                         |
    +-----+----------------------------------+----------------------------------+
    | 1   | Health Check (API ping)          | Every 60 seconds                 |
    | 2   | Balance Verification             | Every 60 seconds                 |
    | 3   | Drawdown Calculation             | Every 60 seconds                 |
    | 4   | BTC Crash Detection              | Every 60 seconds                 |
    | 5   | State File Integrity             | Every 60 seconds [NEW V10.8.2]   |
    | 6   | Heartbeat Telegram               | Every 30 minutes [NEW V10.8]     |
    +-----+----------------------------------+----------------------------------+

[13.2] Health Check Flow:

    EVERY 60 SECONDS:
        1. Ping Nobitex API (GET /v2/options)
        2. IF timeout > 10s:
            - Increment failure_count
        3. IF failure_count >= 3:
            - Trigger HARDWARE KILL SWITCH
        4. IF success:
            - Reset failure_count to 0

[13.3] Heartbeat Message Format [NEW V10.8]:

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ«€ OCEAN HUNTER HEARTBEAT
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â° Time: 2025-12-30 14:30:00
    ğŸ“Š Mode: LIVE_FULL
    ğŸ’° Portfolio: $4,125.50 (+3.14%)
    ğŸ“ˆ Open Positions: 2/3
    ğŸ”„ Queue: 1 signal waiting
    âš¡ BTC Health: NEUTRAL
    ğŸ›¡ï¸ Security: ALL CLEAR
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[13.4] Alert Priority Levels:

    +----------+------------------+----------------------------------------+
    | Level    | Telegram Icon    | Use Case                               |
    +----------+------------------+----------------------------------------+
    | INFO     | â„¹ï¸               | Trade executed, profit taken           |
    | WARNING  | âš ï¸               | Spread high, volume spike              |
    | CRITICAL | ğŸš¨               | Drawdown breach, API failure           |
    | FATAL    | â˜ ï¸               | Kill switch activated                  |
    +----------+------------------+----------------------------------------+
================================================================================
SECTION 14 â€” EXECUTION FLOW (MAIN LOOP)
================================================================================

[14.1] Startup Sequence:

    1. Load .env (API keys)
    2. Load config.py (parameters)
    3. Load/Create state.json
    4. Validate state checksum [NEW V10.8.2]
    5. Verify API connectivity
    6. Sync balances with exchange
    7. Check trading mode (PAPER/LIVE_TEST/LIVE_FULL)
    8. Start Watchdog thread
    9. Send startup alert to Telegram
    10. Enter main loop

[14.2] Main Loop (Every 60 Seconds):

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         MAIN LOOP START                             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 1: Check System State                                          â”‚
    â”‚   - IF HALTED â†’ Skip to END                                         â”‚
    â”‚   - IF EXIT_ONLY â†’ Skip entry logic                                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 2: Fetch Market Data                                           â”‚
    â”‚   - Get OHLCV for all 5 altcoins (M15)                              â”‚
    â”‚   - Get BTC OHLCV (1H) for health check                             â”‚
    â”‚   - Get order books for OBI                                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 3: Security Filters [NEW V10.8.2]                              â”‚
    â”‚   - Check spread for each symbol                                    â”‚
    â”‚   - Check wick anomaly on latest candle                             â”‚
    â”‚   - Check volume sanity                                             â”‚
    â”‚   - IF ANY FILTER TRIGGERED â†’ Flag symbol, reduce/block             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 4: Calculate Indicators                                        â”‚
    â”‚   - RSI(14), EMA(20), BB(20,2), MACD(12,26,9)                       â”‚
    â”‚   - OBI from order book                                             â”‚
    â”‚   - Volume SMA(20)                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 5: Assess BTC Health                                           â”‚
    â”‚   - Determine STRONG / NEUTRAL / WEAK                               â”‚
    â”‚   - IF WEAK â†’ Block new entries [NEW V10.8.1]                       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 6: Score Entry Candidates                                      â”‚
    â”‚   - For each altcoin without open position:                         â”‚
    â”‚     - Calculate entry score (Technical + OBI + Volume + Momentum)   â”‚
    â”‚     - Weights: 35 + 15 + 25 + 25 = 100 [V10.8.1]                    â”‚
    â”‚     - IF score >= 70 â†’ Add to candidates                            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 7: Position Management [NEW V10.8]                             â”‚
    â”‚   - Count open positions                                            â”‚
    â”‚   - IF open_count < 3 â†’ Execute best candidate                      â”‚
    â”‚   - IF open_count >= 3 â†’ Add to WAITING_QUEUE                       â”‚
    â”‚   - Process queue (check expiry, price tolerance)                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 8: Execute Entry (If Approved)                                 â”‚
    â”‚   - Acquire ORDER_LOCK [NEW V10.8.2]                                â”‚
    â”‚   - Place LIMIT order with 0.1% offset [V10.8.1]                    â”‚
    â”‚   - Wait up to 30 seconds for fill                                  â”‚
    â”‚   - IF not filled â†’ Cancel and place MARKET order                   â”‚
    â”‚   - Release ORDER_LOCK                                              â”‚
    â”‚   - Update state.json                                               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 9: Manage Open Positions                                       â”‚
    â”‚   - For each open position:                                         â”‚
    â”‚     - Check exit conditions (TP / Trailing)                         â”‚
    â”‚     - Check DCA triggers                                            â”‚
    â”‚     - Execute DCA if triggered (with PAXG refuel if needed)         â”‚
    â”‚     - Execute exit if profit target hit                             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 10: Profit Distribution                                        â”‚
    â”‚   - IF position closed with profit:                                 â”‚
    â”‚     - Route profit based on BTC health state                        â”‚
    â”‚     - Execute BTC/PAXG purchases                                    â”‚
    â”‚     - Return principal to USDT pool                                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 11: State Persistence                                          â”‚
    â”‚   - Save state.json                                                 â”‚
    â”‚   - Backup if 5 minutes passed [NEW V10.8.2]                        â”‚
    â”‚   - Log trade to trades.xlsx                                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         MAIN LOOP END                               â”‚
    â”‚                    (Wait 60 seconds, repeat)                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
SECTION 15 â€” TESTING PROTOCOL
================================================================================

[15.1] Unit Tests Required:

    +-----+---------------------------+--------------------------------------------+
    | #   | Module                    | Test Cases                                 |
    +-----+---------------------------+--------------------------------------------+
    | 1   | indicators.py             | RSI, EMA, BB, MACD, ATR accuracy           |
    | 2   | orderflow.py              | OBI correctness vs raw order book          |
    | 3   | btc_health.py             | STRONG / NEUTRAL / WEAK classification     |
    | 4   | strategy.py               | Entry score calculation (weighted)         |
    | 5   | dca_manager.py            | DCA triggers, WAIT MODE logic              |
    | 6   | profit_router.py          | Profit split consistency                   |
    | 7   | refuel.py                 | Emergency Refuel conditions                |
    | 8   | rate_limiter.py           | Token bucket + spacing enforcement         |
    | 9   | state_manager.py          | Save / load / checksum / restore           |
    | 10  | security_filters/*        | Spread, Wick, Volume sanity [V10.8.2]      |
    +-----+---------------------------+--------------------------------------------+

[15.2] Integration Tests:

    1. Full lifecycle trade:
        Entry â†’ DCA L1 â†’ DCA L2 â†’ Exit â†’ Profit Split
    2. Emergency Refuel path (PAXG in profit)
    3. WAIT MODE activation (PAXG in loss)
    4. Global Stop activation + recovery
    5. Queue behavior:
        - Add when full
        - Expiry (4h)
        - Price deviation > 2%
    6. API failure simulation
    7. State corruption & auto-restore [NEW V10.8.2]

[15.3] Paper Trading Requirements:

    - Minimum runtime: 72 continuous hours
    - Minimum simulated trades: 10
    - Must include:
        â€¢ One DCA scenario
        â€¢ One trailing exit
        â€¢ One profit routing to BTC
        â€¢ One profit routing to PAXG
    - Must trigger at least:
        â€¢ One security filter event
        â€¢ One heartbeat log
================================================================================
SECTION 16 â€” DEPLOYMENT CHECKLIST
================================================================================

[16.1] Pre-Deployment (MANDATORY):

    [ ] Nobitex API key with READ + TRADE only
    [ ] Withdrawal permission DISABLED
    [ ] IP Whitelist enabled (server IP only) [V10.8.2]
    [ ] .env permissions set to 600
    [ ] .gitignore blocks .env and state.json
    [ ] All unit tests PASSED
    [ ] Paper mode completed (â‰¥72h)
    [ ] Telegram bot tested (alerts + heartbeat)
    [ ] Server timezone = UTC
    [ ] Disk space > 20% free
    [ ] CPU/RAM stable under load

[16.2] Mode Progression (STRICT):

    PAPER
      â””â”€ after 72h + approval â†’
    LIVE_TEST (Max exposure: 50 USDT)
      â””â”€ after 7 days + positive PnL â†’
    LIVE_FULL

[16.3] Go-Live Sequence:

    1. Set MODE = "LIVE_TEST"
    2. Start system
    3. Confirm startup alert
    4. Monitor logs + Telegram closely
    5. Review trades.xlsx daily
    6. Promote to LIVE_FULL only after approval

[16.4] Rollback Plan:

    IF unexpected behavior:
        - Switch MODE to PAPER
        - Disable API key
        - Review logs + state backups
        - Restart only after root cause identified
================================================================================
SECTION 17 â€” FINAL LOCK & ARCHITECTURE STATUS
================================================================================

Architecture Name:
    OCEAN HUNTER â€” COMPLETE SECURE ARCHITECTURE

Version:
    V10.8.2

Trading Type:
    SPOT â€” NO LEVERAGE â€” NO STOP LOSS

Risk Philosophy:
    â€¢ Capital preservation > profit speed
    â€¢ BTC & PAXG = long-term vaults
    â€¢ USDT = operational fuel only

Security Philosophy:
    â€¢ Assume exchange misbehavior
    â€¢ Assume network failure
    â€¢ Assume software bugs
    â€¢ Protect capital above all

Status:
    âœ… ARCHITECTURE COMPLETE
    âœ… SECURITY HARDENED
    âœ… READY FOR IMPLEMENTATION
    âœ… FINAL â€” NO FURTHER CHANGES WITHOUT VERSION BUMP

================================================================================
ARCHITECTURE REFERENCE CODE:
REF-ARCH-V10.8.2-FINAL-LOCK-610
================================================================================


[âœ… Loaded: ARCHITECTURE.txt]

========================================
2. PROJECT STRUCTURE
========================================
[DIR] OCEANHUNTER/
    .env
    .gitignore
    config.py
    main.py
    requirements.txt
    simple_test.py
    smart_connect.py
    state.json
    [DIR] backups/
    [DIR] data/
        [DIR] logs/
        [DIR] ohlcv/
        [DIR] state/
        [DIR] trades/
    [DIR] logs/
    [DIR] modules/
        __init__.py
        [DIR] analysis/
            technical.py
            __init__.py
        [DIR] core/
            __init__.py
        [DIR] data/
            collector.py
            storage.py
            __init__.py
        [DIR] network/
            dns_bypass.py
            mexc_api.py
            nobitex_api.py
            rate_limiter.py
            telegram_bot.py
            __init__.py
        [DIR] security/
            __init__.py
        [DIR] strategy/
            __init__.py
        [DIR] telegram/
            __init__.py
        [DIR] trading/
            __init__.py
        [DIR] watchdog/
            __init__.py

========================================
3. INSTALLED PACKAGES
========================================
aiohappyeyeballs==2.6.1
aiohttp==3.13.2
aiosignal==1.4.0
altair==6.0.0
arabic-reshaper==3.0.0
asttokens==3.0.1
asyncio==4.0.0
attrs==25.4.0
beautifulsoup4==4.14.2
black==22.12.0
blinker==1.9.0
bs4==0.0.2
cachetools==6.2.4
certifi==2025.11.12
charset-normalizer==3.4.4
click==8.3.1
cloudscraper==1.2.71
colorama==0.4.6
contourpy==1.3.3
cycler==0.12.1
DateTime==6.0
decorator==5.2.1
et_xmlfile==2.0.0
executing==2.2.1
finpy_tse==1.2.10
fonttools==4.61.1
frozenlist==1.8.0
gitdb==4.0.12
GitPython==3.1.45
hachoir==3.3.0
idna==3.11
ipython==9.8.0
ipython_pygments_lexers==1.1.1
jalali_core==1.0.0
jdatetime==3.8.2
jedi==0.19.2
Jinja2==3.1.6
jsonschema==4.25.1
jsonschema-specifications==2025.9.1
kiwisolver==1.4.9
lxml==4.9.4
MarkupSafe==3.0.3
matplotlib==3.10.8
matplotlib-inline==0.2.1
multidict==6.7.0
mypy_extensions==1.1.0
narwhals==2.14.0
numpy==2.4.0
openpyxl==3.1.5
packaging==25.0
pandas==2.3.3
parso==0.8.5
pathspec==0.12.1
persiantools==5.4.0
pillow==12.0.0
platformdirs==4.5.1
plotly==6.5.0
prompt_toolkit==3.0.52
propcache==0.4.1
protobuf==6.33.2
pure_eval==0.2.3
pyaes==1.6.1
pyarrow==22.0.0
pyasn1==0.6.1
pydeck==0.9.1
Pygments==2.19.2
pyparsing==3.2.5
python-bidi==0.6.7
python-dateutil==2.9.0.post0
pytse-client==0.19.1
pytz==2025.2
referencing==0.37.0
requests==2.32.5
requests-toolbelt==1.0.0
rpds-py==0.30.0
rsa==4.9.1
six==1.17.0
smmap==5.0.2
soupsieve==2.8
stack-data==0.6.3
streamlit==1.52.2
ta==0.11.0
Telethon==1.42.0
tenacity==7.0.0
toml==0.10.2
tornado==6.5.4
traitlets==5.14.3
typing_extensions==4.15.0
tzdata==2025.3
unsync==1.4.0
urllib3==2.5.0
watchdog==6.0.0
wcwidth==0.2.14
xlsxwriter==3.2.9
yarl==1.22.0
zope.interface==8.1.1

========================================
4. FILE CONTENTS
========================================

==================== START: config.py ====================
#!/usr/bin/env python3
"""Ocean Hunter Configuration â€” MEXC Edition"""
import os
from pathlib import Path
from dotenv import load_dotenv

PROJECT_ROOT = Path(__file__).parent
load_dotenv(PROJECT_ROOT / ".env")

ACTIVE_EXCHANGE = "MEXC"
MEXC_API_KEY = os.getenv("MEXC_API_KEY", "")
MEXC_SECRET_KEY = os.getenv("MEXC_SECRET_KEY", "")
MEXC_BASE_URL = "https://api.mexc.com"
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")
TRADE_COINS = ["BTC", "ETH", "SOL", "XRP", "DOGE"]
QUOTE_CURRENCY = "USDT"
ENTRY_SCORE_MIN = 70
RSI_PERIOD, RSI_OVERSOLD, BB_PERIOD = 14, 35, 20
VOLUME_SMA_PERIOD, VOLUME_SPIKE_MULT = 20, 1.5
TAKE_PROFIT_MIN, TAKE_PROFIT_MAX = 1.5, 3.0
TRAILING_STOP_TRIGGER, TRAILING_STOP_DISTANCE = 1.0, 0.5
MAX_POSITIONS, MIN_ORDER_USDT, RATE_LIMIT_DELAY = 3, 15, 0.5
MODE = os.getenv("MODE", "PAPER")

==================== END: config.py ====================

==================== START: main.py ====================
"""
OCEAN HUNTER â€” Main Entry Point
Tests MEXC API + Telegram Notification
"""

import sys
import os
from datetime import datetime

sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))

def main():
    print("=" * 60)
    print("ğŸŒŠ OCEAN HUNTER V10.8.2 â€” System Test")
    print(f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)

    results = []

    # === TEST 1: MEXC Connection ===
    print("\n[1/5] Testing MEXC Connection...")
    try:
        from modules.network.mexc_api import get_client
        client = get_client()

        # Ping
        ping = client.ping()
        if "error" not in ping:
            print("   âœ… Ping: OK")
            results.append("MEXC Ping: âœ…")
        else:
            print(f"   âŒ Ping Failed: {ping}")
            results.append("MEXC Ping: âŒ")

    except Exception as e:
        print(f"   âŒ MEXC Import Error: {e}")
        results.append(f"MEXC: âŒ {e}")

    # === TEST 2: Server Time ===
    print("\n[2/5] Getting Server Time...")
    try:
        time_resp = client.get_server_time()
        if "serverTime" in time_resp:
            st = time_resp["serverTime"]
            print(f"   âœ… Server Time: {st}")
            results.append("Server Time: âœ…")
        else:
            print(f"   âš ï¸ Response: {time_resp}")
            results.append("Server Time: âš ï¸")
    except Exception as e:
        print(f"   âŒ Error: {e}")
        results.append(f"Server Time: âŒ")

    # === TEST 3: BTC Price ===
    print("\n[3/5] Getting BTC Price...")
    try:
        price = client.get_ticker_price("BTCUSDT")
        if "price" in price:
            p = price["price"]
            print(f"   âœ… BTCUSDT: ${p}")
            results.append(f"BTC Price: ${p}")
        else:
            print(f"   âš ï¸ Response: {price}")
            results.append("BTC Price: âš ï¸")
    except Exception as e:
        print(f"   âŒ Error: {e}")
        results.append("BTC Price: âŒ")

    # === TEST 4: Account Auth ===
    print("\n[4/5] Testing Authentication...")
    try:
        account = client.get_account()
        if "balances" in account:
            count = len(account["balances"])
            print(f"   âœ… Auth Success! Found {count} assets")
            results.append(f"Auth: âœ… ({count} assets)")

            # Show non-zero balances
            for b in account["balances"][:5]:
                free = float(b.get("free", 0))
                locked = float(b.get("locked", 0))
                if free > 0 or locked > 0:
                    print(f"      ğŸ’° {b['asset']}: {free} (locked: {locked})")

        elif "error" in account:
            print(f"   âŒ Auth Failed: {account['error']}")
            results.append(f"Auth: âŒ {account.get('error', 'Unknown')}")
        elif "code" in account:
            print(f"   âŒ API Error {account.get('code')}: {account.get('msg')}")
            results.append(f"Auth: âŒ Code {account.get('code')}")
        else:
            print(f"   âš ï¸ Unexpected: {account}")
            results.append("Auth: âš ï¸")
    except Exception as e:
        print(f"   âŒ Error: {e}")
        results.append(f"Auth: âŒ {e}")

    # === TEST 5: Telegram ===
    print("\n[5/5] Testing Telegram...")
    try:
        from modules.network.telegram_bot import get_bot
        bot = get_bot()

        # First test connection
        if bot.test_connection():
            print("   âœ… Bot Connected")

            # Send report
            report = "ğŸŒŠ <b>OCEAN HUNTER Test Report</b>\n\n"
            report += "\n".join(results)
            report += f"\n\nâ° {datetime.now().strftime('%H:%M:%S')}"

            send_result = bot.send_message(report)
            if send_result.get("ok"):
                print("   âœ… Telegram Message Sent!")
                results.append("Telegram: âœ…")
            else:
                print(f"   âš ï¸ Send Failed: {send_result}")
                results.append("Telegram: âš ï¸")
        else:
            print("   âŒ Bot Connection Failed")
            results.append("Telegram: âŒ")

    except Exception as e:
        print(f"   âŒ Telegram Error: {e}")
        results.append(f"Telegram: âŒ {e}")

    # === SUMMARY ===
    print("\n" + "=" * 60)
    print("ğŸ“Š TEST SUMMARY")
    print("=" * 60)
    for r in results:
        print(f"   {r}")
    print("=" * 60)

    return 0

if __name__ == "__main__":
    sys.exit(main())

==================== END: main.py ====================

==================== START: requirements.txt ====================
requests>=2.31.0
python-dotenv>=1.0.0
pandas>=2.0.0
numpy>=1.24.0
aiohttp>=3.9.0

==================== END: requirements.txt ====================

==================== START: simple_test.py ====================
import requests
import sys

print("-" * 50)
print("ğŸ” DIAGNOSTIC MODE: Checking your connection...")

# 1. Check if VPN is changing our IP
try:
    print("   ğŸŒ Checking Internet & IP...")
    ip_info = requests.get("http://ip-api.com/json", timeout=10).json()
    print(f"   âœ… Internet OK! Your IP: {ip_info['query']}")
    print(f"   ğŸŒ Location: {ip_info['country']} (If this is Iran, VPN is OFF/Not working)")
except Exception as e:
    print(f"   âŒ Internet Check Failed: {e}")
    print("   âš ï¸ WARNING: If you have no internet, Nobitex will definitely fail.")

print("-" * 50)

# 2. Run the simple Nobitex code (Video Method)
url = "https://api.nobitex.ir/market/global-stats"
print(f"ğŸš€ Connecting to {url} ...")

try:
    # verify=False prevents SSL errors common with some VPNs
    response = requests.request("POST", url, verify=False, timeout=15)
    
    if response.status_code == 200:
        print("\nâœ… SUCCESS! (Data received):")
        print(response.text[:200] + "... (truncated)") 
    else:
        print(f"\nâŒ Connected, but server said: HTTP {response.status_code}")
        print(response.text)

except Exception as e:
    print(f"\nâŒ FAILURE: {e}")
    if "11001" in str(e):
        print("   ğŸ‘‰ CAUSE: DNS Failure. Your VPN is likely NOT tunnelling Python traffic.")
    elif "SSL" in str(e):
        print("   ğŸ‘‰ CAUSE: SSL Block. The firewall intercepted the secure connection.")

==================== END: simple_test.py ====================

==================== START: smart_connect.py ====================
import requests
import socket
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def resolve_nobitex_ip():
    print("ğŸ” Attempting to resolve api.nobitex.ir IP...")
    
    # List of known Nobitex IPs (in case DNS fails completely)
    # These are ArvanCloud/Cloudflare IPs often used by Iranian sites
    backup_ips = ["185.143.233.5", "185.143.234.5", "104.26.12.16", "172.67.70.62"]
    
    try:
        # Try system DNS first
        addr_info = socket.getaddrinfo("api.nobitex.ir", 443)
        ip = addr_info[0][4][0]
        print(f"   âœ… System DNS found: {ip}")
        return ip
    except:
        print("   âš ï¸ System DNS failed. Trying manual lookup...")
        # Since we can't query DNS, let's try a direct IP bypass
        # We will use one of the backup IPs
        print(f"   ğŸ‘‰ Using Backup IP: {backup_ips[0]}")
        return backup_ips[0]

def main():
    print("-" * 50)
    print("ğŸš€ OCEAN HUNTER V6.2 â€” SMART CONNECTION")
    print("-" * 50)
    
    target_ip = resolve_nobitex_ip()
    
    # We construct a URL using the IP, but tell the server we want "api.nobitex.ir"
    url = f"https://{target_ip}/market/global-stats"
    
    headers = {
        "Host": "api.nobitex.ir",  # CRITICAL: This tells the server who we are looking for
        "User-Agent": "Mozilla/5.0",
        "Accept": "*/*"
    }
    
    print(f"ğŸ“¡ Connecting to IP: {target_ip} (Host: api.nobitex.ir)...")
    
    try:
        response = requests.post(url, headers=headers, verify=False, timeout=10)
        
        if response.status_code == 200:
            print("\n" + "="*50)
            print("âœ… SUCCESS! CONNECTION ESTABLISHED")
            print("="*50)
            print(f"Data Sample: {response.text[:200]}...")
        else:
            print(f"âŒ Server Error: HTTP {response.status_code}")
            print(response.text)
            
    except Exception as e:
        print(f"âŒ Connection Failed: {e}")
        print("   This might mean the specific IP is blocked or SSL handshake failed.")

if __name__ == "__main__":
    main()

==================== END: smart_connect.py ====================

==================== START: state.json ====================
{
    "positions": {},
    "pending_queue": [],
    "last_heartbeat": null,
    "total_profit_usdt": 0,
    "btc_accumulated": 0,
    "paxg_accumulated": 0
}

==================== END: state.json ====================

==================== START: modules\__init__.py ====================
# Ocean Hunter Modules

==================== END: modules\__init__.py ====================

==================== START: modules\analysis\technical.py ====================
# modules/analysis/technical.py
def calculate_rsi(prices, period=14):
    if len(prices) < period + 1: return 50
    gains, losses = [], []
    for i in range(1, len(prices)):
        delta = prices[i] - prices[i-1]
        gains.append(max(delta, 0))
        losses.append(abs(min(delta, 0)))
    if not gains: return 50
    avg_gain = sum(gains[-period:]) / period
    avg_loss = sum(losses[-period:]) / period
    if avg_loss == 0: return 100
    rs = avg_gain / avg_loss
    return round(100 - (100 / (1 + rs)), 2)

def analyze_market(symbol, candles):
    if not candles: return {"signal": "NEUTRAL", "reason": "No Data", "price": 0, "rsi": 0}
    closes = [c['close'] for c in candles]
    rsi = calculate_rsi(closes)
    signal, reason = "NEUTRAL", f"RSI {rsi}"
    if rsi < 30: signal, reason = "BUY ğŸŸ¢", f"Oversold ({rsi})"
    elif rsi > 70: signal, reason = "SELL ğŸ”´", f"Overbought ({rsi})"
    return {"symbol": symbol, "price": closes[-1], "rsi": rsi, "signal": signal, "reason": reason}

==================== END: modules\analysis\technical.py ====================

==================== START: modules\analysis\__init__.py ====================
# Analysis Module

==================== END: modules\analysis\__init__.py ====================

==================== START: modules\core\__init__.py ====================
# Core Module

==================== END: modules\core\__init__.py ====================

==================== START: modules\data\collector.py ====================
# modules/data/collector.py
import time
from typing import Dict, List, Optional
from modules.network import get_client
from .storage import get_storage

class DataCollector:
    def __init__(self):
        self.client = get_client()

    def test_connection(self):
        """Run DNS check"""
        return self.client.debug_dns()

    def fetch_ohlcv(self, symbol: str) -> tuple[List[Dict], str]:
        try:
            now = int(time.time())
            from_ts = now - (24 * 60 * 60)
            result = self.client.get_ohlcv(symbol=symbol, resolution="60", from_ts=from_ts, to_ts=now)
            
            if result.get("s") != "ok":
                return [], result.get("msg", "Unknown Error")
                
            candles = []
            timestamps = result.get("t", [])
            closes = result.get("c", [])
            for i in range(len(timestamps)):
                candles.append({"timestamp": timestamps[i], "close": float(closes[i])})
            return candles, ""
        except Exception as e:
            return [], str(e)

_collector: Optional[DataCollector] = None
def get_collector() -> DataCollector:
    global _collector
    if _collector is None:
        _collector = DataCollector()
    return _collector

==================== END: modules\data\collector.py ====================

==================== START: modules\data\storage.py ====================
# modules/data/storage.py
import os
import csv
from datetime import datetime
from typing import List, Dict, Any, Optional

class DataStorage:
    def __init__(self, data_dir: str = None):
        if data_dir is None:
            current = os.path.dirname(os.path.abspath(__file__))
            root = os.path.dirname(os.path.dirname(current))
            data_dir = os.path.join(root, "data", "ohlcv")
        self.data_dir = data_dir
        self._ensure_dir()

    def _ensure_dir(self):
        if not os.path.exists(self.data_dir):
            os.makedirs(self.data_dir)

    def _get_filepath(self, symbol: str) -> str:
        safe_symbol = symbol.replace("/", "_").upper()
        return os.path.join(self.data_dir, f"{safe_symbol}.csv")

    def save_ohlcv(self, symbol: str, data: List[Dict]) -> bool:
        if not data:
            return False
        filepath = self._get_filepath(symbol)
        file_exists = os.path.exists(filepath)
        try:
            existing_timestamps = set()
            if file_exists:
                with open(filepath, 'r', encoding='utf-8') as f:
                    reader = csv.DictReader(f)
                    for row in reader:
                        existing_timestamps.add(row.get('timestamp', ''))
            new_data = [row for row in data if str(row.get('timestamp', '')) not in existing_timestamps]
            if not new_data:
                return True
            fieldnames = ['timestamp', 'datetime', 'open', 'high', 'low', 'close', 'volume']
            with open(filepath, 'a', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=fieldnames)
                if not file_exists:
                    writer.writeheader()
                for row in new_data:
                    ts = row.get('timestamp', 0)
                    dt = datetime.fromtimestamp(ts).strftime('%Y-%m-%d %H:%M:%S') if ts else ''
                    writer.writerow({
                        'timestamp': ts, 'datetime': dt,
                        'open': row.get('open', 0), 'high': row.get('high', 0),
                        'low': row.get('low', 0), 'close': row.get('close', 0),
                        'volume': row.get('volume', 0)
                    })
            return True
        except Exception as e:
            print(f"[Storage] Error saving {symbol}: {e}")
            return False

    def get_latest(self, symbol: str, count: int = 100) -> List[Dict]:
        filepath = self._get_filepath(symbol)
        if not os.path.exists(filepath):
            return []
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                rows = list(csv.DictReader(f))
            return rows[-count:] if len(rows) > count else rows
        except Exception as e:
            print(f"[Storage] Error reading {symbol}: {e}")
            return []

    def get_stats(self, symbol: str) -> Dict[str, Any]:
        filepath = self._get_filepath(symbol)
        if not os.path.exists(filepath):
            return {"exists": False, "rows": 0}
        try:
            with open(filepath, 'r', encoding='utf-8') as f:
                rows = list(csv.DictReader(f))
            if not rows:
                return {"exists": True, "rows": 0}
            return {
                "exists": True, "rows": len(rows),
                "first_date": rows[0].get('datetime', 'N/A'),
                "last_date": rows[-1].get('datetime', 'N/A'),
                "file_size_kb": round(os.path.getsize(filepath) / 1024, 2)
            }
        except Exception as e:
            return {"exists": True, "rows": 0, "error": str(e)}

_storage: Optional[DataStorage] = None
def get_storage() -> DataStorage:
    global _storage
    if _storage is None:
        _storage = DataStorage()
    return _storage

==================== END: modules\data\storage.py ====================

==================== START: modules\data\__init__.py ====================
# modules/data/__init__.py
from .collector import DataCollector, get_collector
from .storage import DataStorage, get_storage
__all__ = ["DataCollector", "get_collector", "DataStorage", "get_storage"]

==================== END: modules\data\__init__.py ====================

==================== START: modules\network\dns_bypass.py ====================
# modules/network/dns_bypass.py
import socket
import requests
import json
import random

# --- STATIC FALLBACK IPS ---
# These are known Cloudflare IPs often used by Nobitex.
# Used ONLY if DoH fails.
STATIC_NOBITEX_IPS = [
    "104.26.13.16",
    "104.26.12.16",
    "172.67.70.166"
]

def resolve_doh_google(domain):
    """Resolve IP using Google DNS-over-HTTPS (Bypasses UDP blocks)"""
    try:
        print(f"   â˜ï¸  Requesting DoH from Google for {domain}...")
        url = f"https://dns.google/resolve?name={domain}&type=A"
        # We must disable proxy for the DNS lookup itself
        response = requests.get(url, timeout=5, proxies={"http": None, "https": None})
        
        if response.status_code == 200:
            data = response.json()
            if "Answer" in data:
                # Get the first A record
                for answer in data["Answer"]:
                    if answer["type"] == 1: # Type A
                        ip = answer["data"]
                        print(f"      âœ… DoH Success: {ip}")
                        return ip
    except Exception as e:
        print(f"      âš ï¸ DoH Failed: {e}")
    return None

def get_static_ip():
    """Return a random known IP for Nobitex"""
    ip = random.choice(STATIC_NOBITEX_IPS)
    print(f"   âš ï¸ Using Static Fallback IP: {ip}")
    return ip

# --- MONKEY PATCH ---
REAL_GETADDRINFO = socket.getaddrinfo
CACHED_IP = None

def patched_getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
    global CACHED_IP
    
    if host == "api.nobitex.ir":
        print(f"   ğŸ›¡ï¸ Intercepted: {host}")
        
        if CACHED_IP:
            return [(socket.AF_INET, socket.SOCK_STREAM, 6, '', (CACHED_IP, port))]
            
        # 1. Try DoH (Best Method)
        resolved_ip = resolve_doh_google(host)
        
        # 2. Try Static Fallback (Last Resort)
        if not resolved_ip:
            resolved_ip = get_static_ip()
        
        if resolved_ip:
            print(f"   ğŸ’‰ Injecting: {resolved_ip}")
            CACHED_IP = resolved_ip
            return [(socket.AF_INET, socket.SOCK_STREAM, 6, '', (resolved_ip, port))]
        
    return REAL_GETADDRINFO(host, port, family, type, proto, flags)

def apply_patch():
    socket.getaddrinfo = patched_getaddrinfo

==================== END: modules\network\dns_bypass.py ====================

==================== START: modules\network\mexc_api.py ====================
"""
MEXC API Client â€” Raw Socket Implementation
For OCEAN HUNTER V10.8.2
Fixed: Content-Type header for authentication
"""

import socket
import ssl
import hmac
import hashlib
import time
import json
import os
import logging
from urllib.parse import urlencode
from dotenv import load_dotenv

load_dotenv()
logger = logging.getLogger("MEXC_API")


class MEXCClient:
    """MEXC Spot API via raw HTTPS socket"""

    def __init__(self):
        self.api_key = os.getenv("MEXC_API_KEY", "")
        self.api_secret = os.getenv("MEXC_SECRET_KEY", "")
        self.host = "api.mexc.com"
        self.base_path = "/api/v3"

    def _raw_request(self, method: str, path: str, params: dict = None, signed: bool = False) -> dict:
        """Send HTTPS request via raw socket"""
        params = params or {}

        if signed:
            params["timestamp"] = int(time.time() * 1000)
            query = urlencode(params)
            signature = hmac.new(
                self.api_secret.encode("utf-8"),
                query.encode("utf-8"),
                hashlib.sha256
            ).hexdigest()
            params["signature"] = signature

        query_string = urlencode(params) if params else ""

        if method == "GET":
            full_path = f"{self.base_path}{path}"
            if query_string:
                full_path += f"?{query_string}"
            body = ""
            content_type = "application/json"
        else:
            full_path = f"{self.base_path}{path}"
            body = query_string
            content_type = "application/x-www-form-urlencoded"

        headers = [
            f"{method} {full_path} HTTP/1.1",
            f"Host: {self.host}",
            f"X-MEXC-APIKEY: {self.api_key}",
            f"Content-Type: {content_type}",
            "Connection: close",
        ]

        if body:
            headers.append(f"Content-Length: {len(body)}")

        request = "\r\n".join(headers) + "\r\n\r\n"
        if body:
            request += body

        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.host, 443), timeout=15) as sock:
                with context.wrap_socket(sock, server_hostname=self.host) as ssock:
                    ssock.sendall(request.encode("utf-8"))
                    response = b""
                    while True:
                        chunk = ssock.recv(4096)
                        if not chunk:
                            break
                        response += chunk

            response_text = response.decode("utf-8", errors="ignore")

            if "\r\n\r\n" in response_text:
                _, body_text = response_text.split("\r\n\r\n", 1)
            else:
                body_text = response_text

            if body_text.startswith("{") or body_text.startswith("["):
                return json.loads(body_text)
            else:
                lines = body_text.split("\r\n")
                for line in lines:
                    line = line.strip()
                    if line.startswith("{") or line.startswith("["):
                        return json.loads(line)
            return {"raw": body_text}

        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error: {e}")
            return {"error": str(e)}
        except Exception as e:
            logger.error(f"Request failed: {e}")
            return {"error": str(e)}

    def ping(self) -> dict:
        return self._raw_request("GET", "/ping")

    def get_server_time(self) -> dict:
        return self._raw_request("GET", "/time")

    def get_ticker_price(self, symbol: str = "BTCUSDT") -> dict:
        return self._raw_request("GET", "/ticker/price", {"symbol": symbol})

    def get_orderbook(self, symbol: str, limit: int = 20) -> dict:
        return self._raw_request("GET", "/depth", {"symbol": symbol, "limit": limit})

    def get_account(self) -> dict:
        return self._raw_request("GET", "/account", signed=True)

    def get_balance(self, asset: str = None) -> dict:
        account = self.get_account()
        if "error" in account:
            return account
        balances = account.get("balances", [])
        if asset:
            for b in balances:
                if b.get("asset") == asset:
                    return b
            return {"asset": asset, "free": "0", "locked": "0"}
        return {"balances": balances}

    def create_order(self, symbol: str, side: str, order_type: str,
                     quantity: float, price: float = None) -> dict:
        params = {
            "symbol": symbol,
            "side": side.upper(),
            "type": order_type.upper(),
            "quantity": str(quantity),
        }
        if price and order_type.upper() == "LIMIT":
            params["price"] = str(price)
        return self._raw_request("POST", "/order", params, signed=True)

    def cancel_order(self, symbol: str, order_id: str = None) -> dict:
        params = {"symbol": symbol}
        if order_id:
            params["orderId"] = order_id
        return self._raw_request("DELETE", "/order", params, signed=True)

    def get_open_orders(self, symbol: str = None) -> dict:
        params = {"symbol": symbol} if symbol else {}
        return self._raw_request("GET", "/openOrders", params, signed=True)


_client_instance = None

def get_client() -> MEXCClient:
    global _client_instance
    if _client_instance is None:
        _client_instance = MEXCClient()
    return _client_instance

==================== END: modules\network\mexc_api.py ====================

==================== START: modules\network\nobitex_api.py ====================
# modules/network/nobitex_api.py
import requests
import urllib3
import sys
import os

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Apply Patch
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
try:
    from modules.network.dns_bypass import apply_patch
    apply_patch()
    print("âœ… DoH DNS Engine Activated")
except ImportError as e:
    print(f"âš ï¸ Could not load DNS Bypass: {e}")

class NobitexAPI:
    BASE_URL = "https://api.nobitex.ir"

    def __init__(self):
        self.session = requests.Session()
        # CRITICAL: Disable proxies for the main connection too
        self.session.trust_env = False 
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0 Safari/537.36",
            "Accept": "application/json"
        })

    def get_ohlcv(self, symbol, resolution="60", from_ts=None, to_ts=None):
        url = f"{self.BASE_URL}/market/udf/history"
        params = {"symbol": symbol, "resolution": resolution, "from": from_ts, "to": to_ts}
        
        try:
            print(f"   ğŸ“¡ Connecting to {url} ...")
            # verify=False is needed because we might be using a direct IP which doesn't match the SSL cert
            response = self.session.get(url, params=params, timeout=20, verify=False)
            
            if response.status_code == 200:
                data = response.json()
                if data.get("s") == "ok":
                    return data
                else:
                    return {"s": "error", "msg": f"API Error: {data.get('s')}"}
            else:
                return {"s": "error", "msg": f"HTTP {response.status_code}"}
                
        except Exception as e:
            return {"s": "error", "msg": f"{type(e).__name__}: {str(e)}"}

==================== END: modules\network\nobitex_api.py ====================

==================== START: modules\network\rate_limiter.py ====================
import time
import logging
from collections import deque

logger = logging.getLogger("RateLimiter")

class RateLimiter:
    def __init__(self, max_calls=25, period=60):
        self.max_calls = max_calls
        self.period = period
        self.timestamps = deque()

    def wait_if_needed(self):
        now = time.time()
        while self.timestamps and self.timestamps[0] <= now - self.period:
            self.timestamps.popleft()

        if len(self.timestamps) >= self.max_calls:
            sleep_time = self.timestamps[0] + self.period - now + 0.1
            if sleep_time > 0:
                time.sleep(sleep_time)
            self.wait_if_needed()
        
        self.timestamps.append(time.time())
==================== END: modules\network\rate_limiter.py ====================

==================== START: modules\network\telegram_bot.py ====================
"""
Telegram Bot â€” SOCKS5 Proxy Support
For OCEAN HUNTER V10.8.2
"""

import socket
import ssl
import json
import os
import logging
from urllib.parse import quote
from dotenv import load_dotenv

load_dotenv()
logger = logging.getLogger("TELEGRAM")


class TelegramBot:
    """Telegram Bot via SOCKS5 proxy (Raw Socket)"""

    def __init__(self):
        self.token = os.getenv("TELEGRAM_BOT_TOKEN", "")
        self.chat_id = os.getenv("TELEGRAM_CHAT_ID", "")
        self.proxy_host = os.getenv("PROXY_HOST", "127.0.0.1")
        self.proxy_port = int(os.getenv("PROXY_PORT", "1080"))
        self.use_proxy = os.getenv("USE_PROXY", "true").lower() == "true"
        self.api_host = "api.telegram.org"

    def _socks5_connect(self, target_host: str, target_port: int) -> socket.socket:
        """Connect via SOCKS5 proxy"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(15)
        sock.connect((self.proxy_host, self.proxy_port))

        sock.sendall(b"\x05\x01\x00")
        resp = sock.recv(2)
        if resp != b"\x05\x00":
            raise Exception(f"SOCKS5 handshake failed: {resp.hex()}")

        req = b"\x05\x01\x00\x03"
        req += bytes([len(target_host)]) + target_host.encode()
        req += target_port.to_bytes(2, "big")
        sock.sendall(req)

        resp = sock.recv(10)
        if resp[1] != 0:
            raise Exception(f"SOCKS5 connect failed: code {resp[1]}")

        return sock

    def _direct_connect(self, target_host: str, target_port: int) -> socket.socket:
        """Direct connection without proxy"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(15)
        sock.connect((target_host, target_port))
        return sock

    def _request(self, method: str, params: dict = None) -> dict:
        """Send request to Telegram API"""
        params = params or {}
        path = f"/bot{self.token}/{method}"

        if params:
            query = "&".join(f"{k}={quote(str(v))}" for k, v in params.items())
            path = f"{path}?{query}"

        request = f"GET {path} HTTP/1.1\r\n"
        request += f"Host: {self.api_host}\r\n"
        request += "Connection: close\r\n\r\n"

        try:
            if self.use_proxy:
                sock = self._socks5_connect(self.api_host, 443)
            else:
                sock = self._direct_connect(self.api_host, 443)

            context = ssl.create_default_context()
            with context.wrap_socket(sock, server_hostname=self.api_host) as ssock:
                ssock.sendall(request.encode())
                response = b""
                while True:
                    chunk = ssock.recv(4096)
                    if not chunk:
                        break
                    response += chunk

            text = response.decode("utf-8", errors="ignore")
            if "\r\n\r\n" in text:
                _, body = text.split("\r\n\r\n", 1)
            else:
                body = text

            for line in body.split("\r\n"):
                line = line.strip()
                if line.startswith("{"):
                    return json.loads(line)

            if body.strip().startswith("{"):
                return json.loads(body.strip())

            return {"ok": False, "raw": body[:200]}

        except Exception as e:
            logger.error(f"Telegram request failed: {e}")
            return {"ok": False, "error": str(e)}

    def send_message(self, text: str, chat_id: str = None) -> dict:
        """Send a text message"""
        return self._request("sendMessage", {
            "chat_id": chat_id or self.chat_id,
            "text": text,
            "parse_mode": "HTML"
        })

    def send_alert(self, level: str, message: str) -> dict:
        """Send formatted alert"""
        emojis = {"INFO": "â„¹ï¸", "WARNING": "âš ï¸", "CRITICAL": "ğŸš¨", "SUCCESS": "âœ…"}
        emoji = emojis.get(level.upper(), "ğŸ“Œ")
        text = f"{emoji} <b>{level.upper()}</b>\n{message}"
        return self.send_message(text)

    def test_connection(self) -> bool:
        """Test if bot can connect"""
        result = self._request("getMe")
        return result.get("ok", False)


_bot_instance = None

def get_bot() -> TelegramBot:
    global _bot_instance
    if _bot_instance is None:
        _bot_instance = TelegramBot()
    return _bot_instance

def send_telegram(message: str, level: str = "INFO") -> bool:
    """Quick send function"""
    bot = get_bot()
    result = bot.send_alert(level, message)
    return result.get("ok", False)

==================== END: modules\network\telegram_bot.py ====================

==================== START: modules\network\__init__.py ====================
from .mexc_api import MEXCClient
from .telegram_bot import TelegramBot

def get_client():
    return MEXCClient()

==================== END: modules\network\__init__.py ====================

==================== START: modules\security\__init__.py ====================
# Security Module

==================== END: modules\security\__init__.py ====================

==================== START: modules\strategy\__init__.py ====================
# Strategy Module

==================== END: modules\strategy\__init__.py ====================

==================== START: modules\telegram\__init__.py ====================
# Telegram Module

==================== END: modules\telegram\__init__.py ====================

==================== START: modules\trading\__init__.py ====================
# Trading Module

==================== END: modules\trading\__init__.py ====================

==================== START: modules\watchdog\__init__.py ====================
# Watchdog Module

==================== END: modules\watchdog\__init__.py ====================
