GENERATED: 2026-01-05 23:23:24
VERSION: 3.1 (Phase 1: Virtual Wallet)

PROJECT STRUCTURE:
OCEANHUNTER/
    .env
    config.py
    dashboard.py
    final_system_check.py
    full_test.py
    main.py
    mexc_connect.py
    mexc_sync_test.py
    proxy_fixer.py
    requirements.txt
    run_bot.py
    run_dashboard.py
    setup_test_data.py
    simple_test.py
    smart_connect.py
    split_test.py
    state.json
    test_exchange.py
    test_telegram_conn.py
    Ai_Tools/
        ARCHITECTURE.txt
        build.py
        context_gen.py
        LATEST_PROJECT_CONTEXT.txt
        mexc.txt
        nobitex.txt
        setup_git.py
        telegrambot.txt
        WORKFLOW.txt
    backups/
    modules/
        m_analysis.py
        m_data.py
        m_trader.py
        __init__.py
        analysis/
            technical.py
            __init__.py
        core/
            __init__.py
        network/
            dns_bypass.py
            mexc_api.py
            nobitex_api.py
            rate_limiter.py
            telegram_bot.py
            telegram_client.py
            __init__.py
        security/
            __init__.py
        strategy/
            __init__.py
        telegram/
            __init__.py
        trading/
            __init__.py
        watchdog/
            __init__.py
    tests/
        __init__.py
        core/
            data_engine.py
            interfaces.py
            simulator.py
            test_provider.py
            virtual_wallet.py
            __init__.py
        outputs/
        providers/
            __init__.py
        reporters/
            __init__.py
        runners/
            backtest_runner.py
            __init__.py
        strategies/
            smart_sniper.py
    tools/
        check_live_connection.py
        gen_scenario.py

FILE CONTENTS:

====================
File: .env
====================
# OCEAN HUNTER V10.8.2 â€” Environment Variables
MODE=PAPER
NOBITEX_API_KEY=eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ0b2tlbl9pZCI6NTM1NTY0LCJwYXlsb2FkIjp7ImNsaWVudF9pZCI6ImxlYXJuZXIxNDk1IiwidG9rZW5fdHlwZSI6InRyYWRlIiwiY3JlYXRlX3RpbWUiOjE3MzU3MjA5NjYsImV4cGlyZV90aW1lIjoxNzY3MjU2OTY2LCJzY29wZXMiOlsidHJhZGUiXX19.Vy2YCMQ0LoLqxPDqfVdvLPFCNUQkRA-_6Lo7e3rgDzM
TELEGRAM_BOT_TOKEN=8519168043:AAEeRDhMogTxpElxgB0zUom9YzKXAnRBKew
TELEGRAM_CHAT_ID=6539865961
MAX_POSITION_USDT=100
GLOBAL_STOP_LOSS_PCT=15
MEXC_API_KEY=mx0vglgT1sDiSHvzkz
MEXC_SECRET_KEY=5a9e39d83a7043d19dcbf41d7880eb1a
USE_PROXY=true
PROXY_HOST=127.0.0.1
PROXY_PORT=10808

# === PROXY CONFIG (AUTO-FIXED) ===
PROXY_TYPE=HTTP
PROXY_PORT=10809
PROXY_URL=http://127.0.0.1:10809


====================
File: config.py
====================
#!/usr/bin/env python3
"""Ocean Hunter Configuration â€” MEXC Edition"""
import os
from pathlib import Path
from dotenv import load_dotenv

PROJECT_ROOT = Path(__file__).parent
load_dotenv(PROJECT_ROOT / ".env")

ACTIVE_EXCHANGE = "MEXC"
MEXC_API_KEY = os.getenv("MEXC_API_KEY", "")
MEXC_SECRET_KEY = os.getenv("MEXC_SECRET_KEY", "")
MEXC_BASE_URL = "https://api.mexc.com"
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN", "")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID", "")
TRADE_COINS = ["BTC", "ETH", "SOL", "XRP", "DOGE"]
QUOTE_CURRENCY = "USDT"
ENTRY_SCORE_MIN = 70
RSI_PERIOD, RSI_OVERSOLD, BB_PERIOD = 14, 35, 20
VOLUME_SMA_PERIOD, VOLUME_SPIKE_MULT = 20, 1.5
TAKE_PROFIT_MIN, TAKE_PROFIT_MAX = 1.5, 3.0
TRAILING_STOP_TRIGGER, TRAILING_STOP_DISTANCE = 1.0, 0.5
MAX_POSITIONS, MIN_ORDER_USDT, RATE_LIMIT_DELAY = 3, 15, 0.5
MODE = os.getenv("MODE", "PAPER")


====================
File: dashboard.py
====================
# AI_Tools/build.py â€” Maintenance Mode: Context & Git Sync Only
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ref: OCEAN-SYNC-ONLY
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import os
import sys
from datetime import datetime

# ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ…Ù¾ÙˆØ±Øª Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ ÙˆØ±Ú©â€ŒÙÙ„Ùˆ
try:
    import context_gen
    import setup_git
except ImportError as e:
    print(f"âŒ Critical Error: Missing workflow modules! {e}")
    sys.exit(1)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def force_update():
    print("="*60)
    print("      OCEAN HUNTER | FORCE CONTEXT UPDATE & GIT SYNC")
    print("="*60)
    
    # 1. Update Context
    print("\n[1/2] ğŸ§  Regenerating Project Context...")
    try:
        # ÙØ±Ø§Ø®ÙˆØ§Ù†ÛŒ Ù…Ø³ØªÙ‚ÛŒÙ… ØªØ§Ø¨Ø¹ ØªÙˆÙ„ÛŒØ¯ Ú©Ø§Ù†ØªÚ©Ø³Øª
        context_gen.create_context_file()
        
        # Ø¨Ø±Ø±Ø³ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø¢ÛŒØ§ ÙØ§ÛŒÙ„ ÙˆØ§Ù‚Ø¹Ø§ Ø¢Ù¾Ø¯ÛŒØª Ø´Ø¯Ù‡ Ø§Ø³ØªØŸ
        context_path = os.path.join(os.path.dirname(__file__), "LATEST_PROJECT_CONTEXT.txt")
        if os.path.exists(context_path):
            t = datetime.fromtimestamp(os.path.getmtime(context_path))
            print(f"      âœ… Context File Updated Successfully.")
            print(f"      db Path: {context_path}")
            print(f"      ğŸ•’ Timestamp: {t}")
        else:
            print("      âš ï¸ Warning: File generated but not found at expected path.")
            
    except Exception as e:
        print(f"      âŒ Context Generation Failed: {e}")
        return # Ø§Ú¯Ø± Ú©Ø§Ù†ØªÚ©Ø³Øª Ø³Ø§Ø®ØªÙ‡ Ù†Ø´Ø¯ØŒ Ú¯ÛŒØª Ø³ÛŒÙ†Ú© Ù†Ú©Ù†ÛŒÙ… Ø¨Ù‡ØªØ± Ø§Ø³Øª

    # 2. Git Sync
    print("\n[2/2] ğŸ™ Syncing with GitHub...")
    try:
        # Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Ù¾ÙˆØ´Ù‡ Ú¯ÛŒØª
        root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
        if not os.path.exists(os.path.join(root, ".git")):
            print("      âš™ï¸ Initializing Git first...")
            setup_git.setup()
            
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M')
        commit_msg = f"Manual Sync: Preparation for Cloud Review {timestamp}"
        
        setup_git.sync(commit_msg)
        print("      âœ… Git Push Complete.")
        
    except Exception as e:
        print(f"      âŒ Git Sync Failed: {e}")

if __name__ == "__main__":
    force_update()
    print("\nâœ… OPERATION FINISHED.")
    input("Press Enter to exit...")


====================
File: final_system_check.py
====================
import requests
import os
import time
import urllib3
import hashlib
import hmac
from dotenv import load_dotenv

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
load_dotenv()

# --- CONFIG ---
PROXY_URL = "http://127.0.0.1:10809"
PROXIES = {"http": PROXY_URL, "https": PROXY_URL}

MEXC_BASE = "https://api.mexc.com"
MEXC_KEY = os.getenv("MEXC_API_KEY")
MEXC_SECRET = os.getenv("MEXC_SECRET_KEY")
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

def log(msg):
    print(f"   {msg}")

def get_server_time():
    try:
        url = f"{MEXC_BASE}/api/v3/time"
        resp = requests.get(url, proxies=PROXIES, verify=False, timeout=5)
        if resp.status_code == 200:
            return resp.json()['serverTime']
    except: pass
    return int(time.time() * 1000)

def get_signature(query_string):
    return hmac.new(MEXC_SECRET.encode(), query_string.encode(), hashlib.sha256).hexdigest()

def send_telegram(message):
    print(f"\n[3] ğŸ“¨ Sending Telegram Report...")
    if not TG_TOKEN or not TG_CHAT_ID:
        log("âŒ Telegram Config Missing")
        return

    url = f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
    payload = {"chat_id": TG_CHAT_ID, "text": message}
    
    try:
        resp = requests.post(url, json=payload, proxies=PROXIES, verify=False, timeout=10)
        if resp.status_code == 200:
            log("âœ… Telegram Sent Successfully!")
        else:
            log(f"âŒ Telegram Fail: {resp.text}")
    except Exception as e:
        log(f"âŒ Telegram Error: {e}")

def main():
    print("-" * 50)
    print("ğŸš€ OCEAN HUNTER V6.9 â€” FINAL INTEGRATION")
    print("-" * 50)
    
    # 1. Sync Time
    print("[1] â³ Syncing Time...")
    server_time = get_server_time()
    
    # 2. Check MEXC
    print("[2] ğŸ” Checking MEXC...")
    endpoint = "/api/v3/account"
    query = f"timestamp={server_time}&recvWindow=60000"
    signature = get_signature(query)
    final_url = f"{MEXC_BASE}{endpoint}?{query}&signature={signature}"
    headers = {"X-MEXC-APIKEY": MEXC_KEY}

    report_msg = "ğŸŒŠ OCEAN HUNTER REPORT\n\n"
    report_msg += "âœ… System Online (V6.9)\n"
    report_msg += "âœ… Proxy Active (10809)\n"

    try:
        resp = requests.get(final_url, headers=headers, proxies=PROXIES, verify=False, timeout=10)
        if resp.status_code == 200:
            data = resp.json()
            log("âœ… MEXC Connected!")
            report_msg += "âœ… MEXC Authenticated\n\nğŸ’° Assets:\n"
            
            balances = [b for b in data['balances'] if float(b['free']) > 0]
            if balances:
                for b in balances:
                    line = f"{b['asset']}: {b['free']}"
                    log(f"   ğŸ’° {line}")
                    report_msg += f"- {line}\n"
            else:
                log("   ğŸ’° Wallet Empty")
                report_msg += "- Wallet Empty (Ready to Deposit)\n"
        else:
            err = f"HTTP {resp.status_code} - {resp.text}"
            log(f"âŒ {err}")
            report_msg += f"âŒ MEXC Error: {resp.status_code}"

    except Exception as e:
        log(f"âŒ Error: {e}")
        report_msg += f"âŒ Connection Error: {str(e)[:50]}"

    # 3. Send Report
    send_telegram(report_msg)
    print("-" * 50)

if __name__ == "__main__":
    main()


====================
File: full_test.py
====================
import requests
import os
import time
import urllib3
import hashlib
import hmac
from dotenv import load_dotenv

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
load_dotenv()

# --- CONFIG ---
# We use the working proxy from previous tests
PROXY_URL = "http://127.0.0.1:10809"
PROXIES = {"http": PROXY_URL, "https": PROXY_URL}

MEXC_BASE = "https://api.mexc.com"
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
MEXC_KEY = os.getenv("MEXC_API_KEY")
MEXC_SECRET = os.getenv("MEXC_SECRET_KEY")

def log(msg):
    print(f"   {msg}")

def test_telegram():
    print("\n[1] ğŸ“¨ TESTING TELEGRAM...")
    if not TG_TOKEN or not TG_CHAT_ID:
        log("âŒ FAIL: Token or Chat ID missing in .env")
        return False
    
    url = f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
    payload = {
        "chat_id": TG_CHAT_ID,
        "text": "ğŸŒŠ OCEAN HUNTER: System Operational!\nâœ… Connected to MEXC\nâœ… Proxy Active (10809)"
    }
    
    try:
        log(f"Sending message via proxy {PROXY_URL}...")
        resp = requests.post(url, json=payload, proxies=PROXIES, verify=False, timeout=10)
        if resp.status_code == 200:
            log("âœ… SUCCESS: Check your Telegram now!")
            return True
        else:
            log(f"âŒ FAIL: HTTP {resp.status_code} - {resp.text}")
    except Exception as e:
        log(f"âŒ CONNECTION FAIL: {e}")
    return False

def get_mexc_signature(query_string):
    return hmac.new(MEXC_SECRET.encode(), query_string.encode(), hashlib.sha256).hexdigest()

def test_mexc_private():
    print("\n[2] ğŸ” TESTING MEXC PRIVATE API (ACCOUNT)...")
    if not MEXC_KEY or not MEXC_SECRET:
        log("âš ï¸ SKIPPING: API Keys missing in .env")
        return

    endpoint = "/api/v3/account"
    timestamp = int(time.time() * 1000)
    query = f"timestamp={timestamp}"
    signature = get_mexc_signature(query)
    final_url = f"{MEXC_BASE}{endpoint}?{query}&signature={signature}"
    
    headers = {"X-MEXC-APIKEY": MEXC_KEY}

    try:
        resp = requests.get(final_url, headers=headers, proxies=PROXIES, verify=False, timeout=10)
        if resp.status_code == 200:
            data = resp.json()
            log("âœ… SUCCESS: Account Accessible.")
            # Show balances
            balances = [b for b in data['balances'] if float(b['free']) > 0 or float(b['locked']) > 0]
            if balances:
                for b in balances:
                    log(f"ğŸ’° Balance: {b['asset']} = {b['free']}")
            else:
                log("ğŸ’° Balance: Wallet is empty (but connected).")
        elif resp.status_code == 401:
            log("âŒ AUTH FAIL: Invalid API Key or Permissions.")
            log(f"Response: {resp.text}")
        else:
            log(f"âŒ HTTP ERROR {resp.status_code}: {resp.text}")
            
    except Exception as e:
        log(f"âŒ CONNECTION ERROR: {e}")

def main():
    print("-" * 50)
    print("ğŸš€ OCEAN HUNTER V6.7 â€” FINAL INTEGRATION TEST")
    print("-" * 50)
    
    tg_ok = test_telegram()
    test_mexc_private()
    
    print("-" * 50)
    if tg_ok:
        print("ğŸ‰ GREAT JOB! The bot is ready to hunt on MEXC.")
    else:
        print("âš ï¸ Telegram failed. Check your Token/ChatID or VPN.")

if __name__ == "__main__":
    main()


====================
File: main.py
====================
import os
import time
import requests
import urllib3
from dotenv import load_dotenv
from modules.m_data import DataEngine
from modules.m_analysis import analyze_market
from modules.m_trader import PaperTrader

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
load_dotenv()

# --- CONFIG ---
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
PROXY_URL = "http://127.0.0.1:10809"
PROXIES = {"http": PROXY_URL, "https": PROXY_URL}

def send_telegram(msg):
    if not TG_TOKEN or not TG_CHAT_ID: return
    url = f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
    payload = {"chat_id": TG_CHAT_ID, "text": msg}
    try:
        requests.post(url, json=payload, proxies=PROXIES, verify=False, timeout=5)
    except: pass

def main():
    print("-" * 50)
    print("ğŸ“œ OCEAN HUNTER V8.0 â€” PAPER TRADING")
    print("-" * 50)
    
    engine = DataEngine()
    trader = PaperTrader(initial_balance=1000) # Start with $1000 Fake USDT
    
    targets = ["BTCUSDT", "ETHUSDT", "SOLUSDT", "BNBUSDT", "XRPUSDT"]
    current_prices = {}
    
    report_msg = "ğŸ“œ PAPER TRADING REPORT (V8.0)\n"
    report_msg += "Strategy: RSI (14) | Fake Balance: $1000\n"
    report_msg += "â”€" * 25 + "\n\n"
    
    trade_logs = []

    for symbol in targets:
        # 1. Fetch Data
        candles = engine.fetch_candles(symbol, interval="60m", limit=50)
        
        if candles:
            # 2. Analyze
            result = analyze_market(symbol, candles)
            current_prices[symbol] = result['price']
            
            # 3. Execute Trade (Simulation)
            trade_action = trader.execute(symbol, result['signal'], result['price'])
            
            if trade_action:
                trade_logs.append(trade_action)
                print(f"   âš¡ ACTION: {trade_action}")
            
            # Format Report
            icon = "âšª"
            if "BUY" in result['signal']: icon = "ğŸŸ¢"
            elif "SELL" in result['signal']: icon = "ğŸ”´"
            
            line = f"{icon} {symbol.replace('USDT','')}: ${result['price']}\n"
            line += f"   RSI: {result['rsi']} ({result['signal'].split()[0]})\n"
            report_msg += line + "\n"
        else:
            report_msg += f"âŒ {symbol}: Connection Failed\n"
            
    # 4. Portfolio Summary
    total_val = trader.get_portfolio_value(current_prices)
    roi = ((total_val - 1000) / 1000) * 100
    
    report_msg += "â”€" * 25 + "\n"
    report_msg += f"ğŸ’° Wallet: ${trader.state['usdt_balance']:.2f}\n"
    report_msg += f"ğŸ“Š Net Worth: ${total_val:.2f} ({roi:+.2f}%)\n"
    
    if trade_logs:
        report_msg += "\nğŸ“ NEW TRADES:\n" + "\n".join(trade_logs)
            
    print(f"\n[4] ğŸ“¨ Sending Report (Val: ${total_val:.2f})...")
    send_telegram(report_msg)
    print("âœ… Done.")

if __name__ == "__main__":
    main()


====================
File: mexc_connect.py
====================
import requests
import os
import time
import urllib3
from dotenv import load_dotenv

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
load_dotenv()

# We use the proxy found in V6.4/V6.5
PROXY_URL = "http://127.0.0.1:10809"
PROXIES = {"http": PROXY_URL, "https": PROXY_URL}

def main():
    print("-" * 50)
    print("ğŸš€ OCEAN HUNTER V6.6 â€” MEXC ACTIVATION")
    print("-" * 50)
    print(f"ğŸ”Œ Proxy: {PROXY_URL}")

    # 1. Public Endpoint Check (Ping)
    print("\n[1] Pinging MEXC Public API...")
    try:
        url = "https://api.mexc.com/api/v3/ping"
        resp = requests.get(url, proxies=PROXIES, verify=False, timeout=10)
        
        if resp.status_code == 200:
            print("   âœ… MEXC Server is REACHABLE!")
            print(f"   Response: {resp.json()}")
        else:
            print(f"   âŒ Failed to ping: HTTP {resp.status_code}")
            return # Stop if we can't even ping
            
    except Exception as e:
        print(f"   âŒ Connection Error: {e}")
        print("   âš ï¸ Ensure V2RayN is running on port 10809!")
        return

    # 2. Market Data Check
    print("\n[2] Fetching BTC Price...")
    try:
        url = "https://api.mexc.com/api/v3/ticker/price?symbol=BTCUSDT"
        resp = requests.get(url, proxies=PROXIES, verify=False, timeout=10)
        data = resp.json()
        
        print(f"   ğŸ’° BTC Price: {data['price']} USDT")
        print("   âœ… Market Data Flow is WORKING.")
        
    except Exception as e:
        print(f"   âŒ Market Data Failed: {e}")

    # 3. Check for Credentials
    api_key = os.getenv("MEXC_API_KEY")
    secret_key = os.getenv("MEXC_SECRET_KEY")
    
    print("\n[3] Checking Credentials...")
    if not api_key or "your_api_key" in api_key:
        print("   âš ï¸  WARNING: API Key not set in .env file.")
        print("   ğŸ‘‰ Please open .env and paste your MEXC keys.")
    else:
        print("   âœ… API Key found in config.")
        print("   (We will test trade authentication in the next step)")

if __name__ == "__main__":
    main()


====================
File: mexc_sync_test.py
====================
import requests
import os
import time
import urllib3
import hashlib
import hmac
from dotenv import load_dotenv

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
load_dotenv()

# --- CONFIG ---
PROXY_URL = "http://127.0.0.1:10809"
PROXIES = {"http": PROXY_URL, "https": PROXY_URL}
MEXC_BASE = "https://api.mexc.com"
MEXC_KEY = os.getenv("MEXC_API_KEY")
MEXC_SECRET = os.getenv("MEXC_SECRET_KEY")

def log(msg):
    print(f"   {msg}")

def get_server_time():
    """Gets precise server time from MEXC to fix timestamp errors"""
    try:
        url = f"{MEXC_BASE}/api/v3/time"
        resp = requests.get(url, proxies=PROXIES, verify=False, timeout=5)
        if resp.status_code == 200:
            return resp.json()['serverTime']
    except Exception as e:
        log(f"âš ï¸ Could not fetch server time: {e}")
    return int(time.time() * 1000)

def get_signature(query_string):
    return hmac.new(MEXC_SECRET.encode(), query_string.encode(), hashlib.sha256).hexdigest()

def test_account_with_sync():
    print("-" * 50)
    print("ğŸš€ OCEAN HUNTER V6.8 â€” TIME SYNC FIX")
    print("-" * 50)
    
    if not MEXC_KEY or not MEXC_SECRET:
        log("âŒ FAIL: API Keys missing in .env")
        return

    # 1. Get Server Time
    print("[1] â³ Synchronizing Clock...")
    server_time = get_server_time()
    local_time = int(time.time() * 1000)
    diff = server_time - local_time
    log(f"Server Time: {server_time}")
    log(f"Local Time:  {local_time}")
    log(f"Difference:  {diff} ms")

    # 2. Prepare Request with recvWindow
    print("\n[2] ğŸ” Checking Account Balance...")
    endpoint = "/api/v3/account"
    
    # We use server_time directly and add a large recvWindow (60s)
    query = f"timestamp={server_time}&recvWindow=60000"
    signature = get_signature(query)
    final_url = f"{MEXC_BASE}{endpoint}?{query}&signature={signature}"
    
    headers = {"X-MEXC-APIKEY": MEXC_KEY}

    try:
        resp = requests.get(final_url, headers=headers, proxies=PROXIES, verify=False, timeout=10)
        
        if resp.status_code == 200:
            data = resp.json()
            log("âœ… SUCCESS! Authentication Passed.")
            
            # Show balances
            balances = [b for b in data['balances'] if float(b['free']) > 0 or float(b['locked']) > 0]
            if balances:
                print("\n   ğŸ’° YOUR WALLET ASSETS:")
                for b in balances:
                    print(f"      - {b['asset']}: {b['free']}")
            else:
                log("ğŸ’° Balance: Wallet is empty (but connected).")
                
        elif resp.status_code == 400:
             log(f"âŒ TIMESTAMP ERROR: {resp.text}")
             log("ğŸ‘‰ Solution: Check your PC clock settings to be 'Automatic'.")
        elif resp.status_code == 401:
            log("âŒ AUTH FAIL: Invalid API Key or Permissions.")
        else:
            log(f"âŒ HTTP ERROR {resp.status_code}: {resp.text}")
            
    except Exception as e:
        log(f"âŒ CONNECTION ERROR: {e}")

if __name__ == "__main__":
    test_account_with_sync()


====================
File: proxy_fixer.py
====================
import requests
import socket
import os
import urllib3
from dotenv import load_dotenv

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)
load_dotenv()

def check_port(ip, port):
    """Checks if a local port is open."""
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(1)
    result = sock.connect_ex((ip, int(port)))
    sock.close()
    return result == 0

def test_connection(proxy_url, name):
    print(f"\nğŸ”Œ Testing Proxy: {name} -> {proxy_url}")
    proxies = {"http": proxy_url, "https": proxy_url}
    
    try:
        # 1. Test against generic Internet (IP Check)
        print("   Step 1: Pinging Global Internet (ip-api)...")
        resp = requests.get("http://ip-api.com/json", proxies=proxies, timeout=5)
        data = resp.json()
        print(f"   âœ… Internet OK! IP: {data.get('query')} ({data.get('countryCode')})")
        
        # 2. Test against Nobitex (Target)
        print("   Step 2: Pinging Nobitex API...")
        nobitex_url = "https://api.nobitex.ir/market/global-stats"
        resp_nobitex = requests.post(nobitex_url, proxies=proxies, verify=False, timeout=5)
        
        if resp_nobitex.status_code == 200:
            print("   âœ…âœ…âœ… NOBITEX CONNECTED SUCCESSFULLY! âœ…âœ…âœ…")
            return True
        else:
            print(f"   âš ï¸ Connected, but HTTP {resp_nobitex.status_code}")
            return False

    except Exception as e:
        print(f"   âŒ Failed: {e}")
        return False

def main():
    print("-" * 50)
    print("ğŸš€ OCEAN HUNTER V6.4 â€” PROXY AUTO-FIXER")
    print("-" * 50)

    # Candidates to check
    candidates = []
    
    # 1. Check Env Var Port (Likely wrong: 2081)
    env_port = os.getenv("PROXY_PORT")
    if env_port:
        candidates.append(("ENV_CONFIG", "127.0.0.1", int(env_port), "http"))

    # 2. Check Standard V2RayN HTTP (Best for Python)
    candidates.append(("V2RAY_HTTP", "127.0.0.1", 10809, "http"))
    
    # 3. Check Standard V2RayN SOCKS (Alternative)
    candidates.append(("V2RAY_SOCKS", "127.0.0.1", 10808, "socks5"))

    valid_proxy_found = False

    for name, ip, port, protocol in candidates:
        if check_port(ip, port):
            print(f"\nğŸ” Port {port} ({name}) is OPEN.")
            
            # Construct proxy string
            if protocol == "socks5":
                # Ensure pysocks is installed for this, otherwise skip or fallback
                proxy_str = f"socks5h://{ip}:{port}"
            else:
                proxy_str = f"http://{ip}:{port}"

            if test_connection(proxy_str, name):
                valid_proxy_found = True
                print("\n" + "="*50)
                print(f"ğŸ’¡ FIX FOUND: Update your .env file to use PORT {port}")
                print(f"   Change PROXY_PORT={port}")
                print(f"   Change PROXY_TYPE={protocol.upper()}")
                print("="*50)
                break
        else:
            print(f"âŒ Port {port} ({name}) is CLOSED (Not running).")

    if not valid_proxy_found:
        print("\nâš ï¸ NO WORKING PROXY FOUND.")
        print("   1. Ensure V2RayN is RUNNING.")
        print("   2. Ensure the bottom bar says 'Enable Tun' or 'System Proxy' is NOT needed, but the core must be running.")

if __name__ == "__main__":
    main()


====================
File: requirements.txt
====================
python-dotenv
requests
pandas

====================
File: run_bot.py
====================

import os
import time
import requests
import statistics
import math
from datetime import datetime
from dotenv import load_dotenv

# Load Environment
load_dotenv()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONFIG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SYMBOL = "BTCUSDT"
TIMEFRAME = "1m"
ENTRY_THRESHOLD = 70       # Enter if Score >= 70
TAKE_PROFIT_PCT = 1.5      # Sell if Profit >= 1.5%
STOP_LOSS_PCT = -2.0       # Sell if Loss >= 2.0% (Simulated Safety)

# API CONFIG
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
PROXY_URL = os.getenv("HTTPS_PROXY", "http://127.0.0.1:10809")
PROXIES = {"http": PROXY_URL, "https": PROXY_URL}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PAPER WALLET â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PaperWallet:
    def __init__(self, initial_usdt=1000):
        self.usdt = initial_usdt
        self.btc = 0.0
        self.entry_price = 0.0
        self.in_position = False
        self.trades = 0

    def buy(self, price):
        if self.in_position: return False
        amount_to_buy = self.usdt  # All in for simulation
        self.btc = amount_to_buy / price
        self.usdt = 0
        self.entry_price = price
        self.in_position = True
        return True

    def sell(self, price, reason):
        if not self.in_position: return False
        sale_value = self.btc * price
        pnl = sale_value - (self.btc * self.entry_price)
        pnl_pct = (pnl / (self.btc * self.entry_price)) * 100
        
        self.usdt = sale_value
        self.btc = 0
        self.in_position = False
        self.trades += 1
        return pnl, pnl_pct

wallet = PaperWallet(initial_usdt=1000)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TELEGRAM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def send_telegram(msg):
    if not TG_TOKEN or not TG_CHAT_ID: return
    url = f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
    payload = {"chat_id": TG_CHAT_ID, "text": msg, "parse_mode": "HTML"}
    try:
        requests.post(url, json=payload, timeout=5)
    except:
        try:
            requests.post(url, json=payload, proxies=PROXIES, timeout=5)
        except: pass

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MARKET DATA â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def get_market_data():
    base_url = "https://api.mexc.com/api/v3/klines"
    params = {"symbol": SYMBOL, "interval": TIMEFRAME, "limit": 50}
    try:
        resp = requests.get(base_url, params=params, timeout=5)
        return resp.json()
    except:
        try:
            resp = requests.get(base_url, params=params, proxies=PROXIES, timeout=5)
            return resp.json()
        except: return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INDICATORS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def calculate_indicators(klines):
    if not klines: return None
    closes = [float(k[4]) for k in klines]
    opens = [float(k[1]) for k in klines]
    volumes = [float(k[5]) for k in klines]
    
    # RSI
    period = 14
    if len(closes) < period + 1: return None
    deltas = [closes[i] - closes[i-1] for i in range(1, len(closes))]
    gains = [d if d > 0 else 0 for d in deltas]
    losses = [abs(d) if d < 0 else 0 for d in deltas]
    avg_gain = sum(gains[-period:]) / period
    avg_loss = sum(losses[-period:]) / period
    rs = avg_gain / avg_loss if avg_loss != 0 else 0
    rsi = 100 - (100 / (1 + rs)) if avg_loss != 0 else 100

    # BB
    slice_data = closes[-20:]
    sma = sum(slice_data) / 20
    std = statistics.stdev(slice_data)
    bb_lower = sma - (2 * std)

    # Volume Spike
    curr_vol = volumes[-1]
    avg_vol = sum(volumes[-21:-1]) / 20
    vol_spike = curr_vol > (1.5 * avg_vol)

    return {
        "price": closes[-1],
        "rsi": rsi,
        "bb_lower": bb_lower,
        "vol_spike": vol_spike,
        "is_green": closes[-1] > opens[-1]
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SCORING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def get_score(data):
    score = 0
    reasons = []
    if data['rsi'] < 40: score += 20; reasons.append("RSI Oversold")
    if data['price'] < data['bb_lower']: score += 15; reasons.append("Below BB")
    if data['vol_spike']: score += 25; reasons.append("Vol Spike")
    if data['is_green']: score += 25; reasons.append("Bullish Candle")
    return score, reasons

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN LOOP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def main():
    os.system('cls' if os.name == 'nt' else 'clear')
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print(f"â•‘ ğŸ“ PAPER TRADING SIMULATION (SAFE MODE)          â•‘")
    print(f"â•‘ ğŸ’° Wallet: ${wallet.usdt:.2f} USDT                      â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    send_telegram("ğŸ“ <b>PAPER TRADING STARTED</b>\nSimulated Wallet: $1000")
    
    try:
        while True:
            klines = get_market_data()
            if klines:
                data = calculate_indicators(klines)
                score, reasons = get_score(data)
                price = data['price']
                
                # Console Output
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                if wallet.in_position:
                    # CHECK FOR EXIT
                    curr_val = wallet.btc * price
                    pnl_pct = ((curr_val - 1000) / 1000) * 100 # Approx PnL based on initial
                    pnl_color = "\033[92m" if pnl_pct > 0 else "\033[91m"
                    
                    print(f"[{timestamp}] ğŸ’¼ HOLDING | Price: {price} | PnL: {pnl_color}{pnl_pct:.2f}%\033[0m")
                    
                    # Exit Conditions
                    exit_msg = ""
                    if pnl_pct >= TAKE_PROFIT_PCT:
                        pnl, pct = wallet.sell(price, "Take Profit")
                        exit_msg = f"âœ… <b>TAKE PROFIT</b> (+{pct:.2f}%)"
                    elif pnl_pct <= STOP_LOSS_PCT:
                        pnl, pct = wallet.sell(price, "Stop Loss")
                        exit_msg = f"ğŸ›‘ <b>STOP LOSS</b> ({pct:.2f}%)"
                    
                    if exit_msg:
                        print(f"\nğŸ’° {exit_msg} | New Balance: ${wallet.usdt:.2f}\n")
                        send_telegram(f"{exit_msg}\nPrice: {price}\nBalance: ${wallet.usdt:.2f}")

                else:
                    # CHECK FOR ENTRY
                    s_color = "\033[92m" if score >= ENTRY_THRESHOLD else "\033[90m"
                    print(f"[{timestamp}] ğŸ” {price} | Score: {s_color}{score}/100\033[0m | RSI: {data['rsi']:.1f}")
                    
                    if score >= ENTRY_THRESHOLD:
                        wallet.buy(price)
                        msg = (f"ğŸš€ <b>SIMULATED BUY</b>\n"
                               f"Price: {price}\n"
                               f"Score: {score}\n"
                               f"Reasons: {', '.join(reasons)}")
                        print(f"\nğŸ›’ BUY EXECUTED at {price}\n")
                        send_telegram(msg)
            else:
                print("âš ï¸  Network glitch...", end='\r')
                
            time.sleep(10)

    except KeyboardInterrupt:
        print("\nğŸ›‘ Bot Stopped.")

if __name__ == "__main__":
    main()


====================
File: run_dashboard.py
====================

import os
import sys
import subprocess
import time
from dotenv import load_dotenv

load_dotenv()

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
os.chdir(CURRENT_DIR)

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def print_banner():
    clear_screen()
    print(Colors.CYAN + "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—" + Colors.ENDC)
    print(Colors.CYAN + "â•‘   " + Colors.BOLD + "ğŸŒŠ OCEAN HUNTER | COMMAND CENTER v2.7" + Colors.ENDC + Colors.CYAN + "                  â•‘" + Colors.ENDC)
    print(Colors.CYAN + "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" + Colors.ENDC)
    print(f" ğŸ“ Root: {os.getcwd()}")
    
    if os.getenv("TELEGRAM_BOT_TOKEN"):
        print(f" ğŸ” Telegram: {Colors.GREEN}Configured{Colors.ENDC}")
    else:
        print(f" ğŸ” Telegram: {Colors.FAIL}MISSING IN .ENV{Colors.ENDC}")
    print(Colors.BLUE + "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" + Colors.ENDC)

def run_script(script_name):
    print(f"\n{Colors.WARNING}>> Running {script_name}...{Colors.ENDC}")
    time.sleep(1)
    python_exec = sys.executable
    try:
        subprocess.run([python_exec, script_name], cwd=CURRENT_DIR)
    except Exception as e:
        print(f"{Colors.FAIL}Error: {e}{Colors.ENDC}")
    input(f"\n{Colors.BLUE}[Press Enter]{Colors.ENDC}")

def main_menu():
    while True:
        print_banner()
        print(" [1] ğŸš€ START BOT (Live)")
        print(" [2] ğŸ›¡ï¸ START BOT (Safe Mode)")
        print(" [3] ğŸ“¡ TEST TELEGRAM (Auto-Detect Proxy)")
        print(" [4] ğŸ› ï¸ RE-BUILD (Update Code)")
        print(" [5] âŒ EXIT")
        print("\n" + Colors.BLUE + "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" + Colors.ENDC)
        
        try:
            choice = input(f"{Colors.GREEN}>> Select: {Colors.ENDC}").strip()
        except:
            break

        if choice == '1':
            os.environ['MODE'] = 'LIVE'
            run_script("run_bot.py")
        elif choice == '2':
            os.environ['MODE'] = 'SAFE'
            run_script("run_bot.py")
        elif choice == '3':
            run_script("test_telegram_conn.py")
        elif choice == '4':
            run_script(os.path.join("Ai_Tools", "build.py"))
        elif choice == '5':
            break
        else:
            print("Invalid.")
            time.sleep(0.5)

if __name__ == "__main__":
    os.system('color')
    main_menu()


====================
File: setup_test_data.py
====================
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
OCEAN HUNTER V10.8.2 - Test Data Generator
Auto-creates all test folders and data files
Run from project root: python setup_test_data.py
"""

import os
import json
from pathlib import Path

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 1: DIRECTORY STRUCTURE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BASE_DIR = Path(__file__).parent / "tests"

DIRECTORIES = [
    "data/candles",
    "data/orderbooks", 
    "data/scenarios",
    "data/wallets",
    "providers",
    "runners",
    "reporters",
    "outputs"
]

def create_directories():
    """Create all required test directories"""
    print("=" * 60)
    print("ğŸ“ Creating directory structure...")
    print("=" * 60)
    
    for dir_path in DIRECTORIES:
        full_path = BASE_DIR / dir_path
        full_path.mkdir(parents=True, exist_ok=True)
        print(f"  âœ… Created: {full_path}")
    
    # Create __init__.py files
    init_dirs = ["", "providers", "runners", "reporters"]
    for dir_name in init_dirs:
        init_file = BASE_DIR / dir_name / "__init__.py"
        init_file.touch(exist_ok=True)
        print(f"  âœ… Created: {init_file}")
    
    # Create .gitkeep in outputs
    gitkeep = BASE_DIR / "outputs" / ".gitkeep"
    gitkeep.touch(exist_ok=True)
    
    print("\nâœ… Directory structure complete!\n")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 2: WALLET DATA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

INITIAL_WALLET = {
    "version": "V10.8.2",
    "created": "2026-01-04",
    "description": "Initial wallet state for testing",
    "balances": {
        "USDT": {"available": 400.0, "locked": 0.0},
        "SOL": {"available": 0.0, "locked": 0.0, "avg_price": 0.0},
        "BNB": {"available": 0.0, "locked": 0.0, "avg_price": 0.0},
        "XRP": {"available": 0.0, "locked": 0.0, "avg_price": 0.0},
        "AVAX": {"available": 0.0, "locked": 0.0, "avg_price": 0.0},
        "LINK": {"available": 0.0, "locked": 0.0, "avg_price": 0.0},
        "BTC": {"available": 0.005, "locked": 0.0, "avg_price": 42000.0},
        "PAXG": {"available": 0.08, "locked": 0.0, "avg_price": 2500.0}
    },
    "settings": {
        "fee_rate": 0.0035,
        "max_positions": 3,
        "position_size_usdt": 100.0
    }
}

def create_wallet():
    """Create initial wallet JSON file"""
    print("=" * 60)
    print("ğŸ’° Creating wallet file...")
    print("=" * 60)
    
    wallet_path = BASE_DIR / "data/wallets/initial_wallet_v10.8.2.json"
    with open(wallet_path, 'w', encoding='utf-8') as f:
        json.dump(INITIAL_WALLET, f, indent=2, ensure_ascii=False)
    
    print(f"  âœ… Created: {wallet_path}")
    print("\nâœ… Wallet file complete!\n")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 3: CANDLE DATA GENERATOR
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def generate_candles(symbol, timeframe, base_price, scenarios):
    """
    Generate candle data with specific scenarios
    
    scenarios: list of tuples (candle_index, tag, price_modifier)
    """
    candles = []
    current_price = base_price
    base_timestamp = 1704067200  # 2024-01-01 00:00:00
    
    # Timeframe to seconds
    tf_seconds = 900 if timeframe == "M15" else 3600  # M15=900s, 1H=3600s
    
    for i in range(100):
        timestamp = base_timestamp + (i * tf_seconds)
        
        # Check if this candle has a special scenario
        tag = "NORMAL"
        price_mod = 1.0
        
        for sc_idx, sc_tag, sc_mod in scenarios:
            if i == sc_idx:
                tag = sc_tag
                price_mod = sc_mod
                break
        
        # Generate OHLCV
        current_price *= price_mod
        variance = current_price * 0.005  # 0.5% variance
        
        open_p = current_price
        high_p = current_price + variance
        low_p = current_price - variance
        close_p = current_price + (variance * 0.3)
        volume = 10000 + (i * 100)
        
        candles.append({
            "timestamp": timestamp,
            "open": round(open_p, 2),
            "high": round(high_p, 2),
            "low": round(low_p, 2),
            "close": round(close_p, 2),
            "volume": volume,
            "scenario_tag": tag
        })
        
        current_price = close_p
    
    return candles

def save_candles_csv(candles, filename):
    """Save candles to CSV file"""
    filepath = BASE_DIR / "data/candles" / filename
    
    with open(filepath, 'w', encoding='utf-8') as f:
        # Header
        f.write("timestamp,open,high,low,close,volume,scenario_tag\n")
        
        # Data
        for c in candles:
            f.write(f"{c['timestamp']},{c['open']},{c['high']},{c['low']},{c['close']},{c['volume']},{c['scenario_tag']}\n")
    
    print(f"  âœ… Created: {filepath}")
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 4: ALL CANDLE DEFINITIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CANDLE_CONFIGS = {
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # SOL - Solana
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "SOL_M15": {
        "symbol": "SOL", "timeframe": "M15", "base_price": 95.0,
        "scenarios": [
            (15, "ENTRY_SIGNAL", 1.02),
            (45, "EXIT_PROFIT", 1.025),
            (70, "ENTRY_SIGNAL", 0.98),
            (90, "EXIT_PROFIT", 1.03)
        ]
    },
    "SOL_M15_DCA": {
        "symbol": "SOL", "timeframe": "M15", "base_price": 100.0,
        "scenarios": [
            (10, "ENTRY_SIGNAL", 1.0),
            (18, "DCA_LAYER1_TRIGGER", 0.97),
            (25, "DCA_LAYER2_TRIGGER", 0.94),
            (32, "DCA_LAYER3_TRIGGER", 0.90),
            (50, "RECOVERY_START", 1.05),
            (70, "DCA_EXIT_PROFIT", 1.08)
        ]
    },
    "SOL_M15_TRAILING": {
        "symbol": "SOL", "timeframe": "M15", "base_price": 95.0,
        "scenarios": [
            (5, "ENTRY_SIGNAL", 1.02),
            (10, "TRAILING_ACTIVATED", 1.03),
            (12, "NEW_HIGH", 1.02),
            (14, "NEW_HIGH", 1.015),
            (16, "NEW_HIGH", 1.01),
            (20, "TRAILING_EXIT", 0.985)
        ]
    },
    "SOL_M15_GLOBAL_STOP": {
        "symbol": "SOL", "timeframe": "M15", "base_price": 100.0,
        "scenarios": [
            (3, "ENTRY_SIGNAL", 1.0),
            (8, "DECLINE_START", 0.96),
            (12, "GLOBAL_STOP_HIT", 0.88)
        ]
    },
    "SOL_1H": {
        "symbol": "SOL", "timeframe": "1H", "base_price": 95.0,
        "scenarios": [
            (10, "MULTI_TF_CONFIRM", 1.02),
            (30, "EXIT_SIGNAL", 1.03)
        ]
    },
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # BNB - Binance Coin
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "BNB_M15": {
        "symbol": "BNB", "timeframe": "M15", "base_price": 315.0,
        "scenarios": [
            (15, "ENTRY_SIGNAL", 1.02),
            (45, "EXIT_PROFIT", 1.025),
            (75, "ENTRY_SIGNAL", 0.98),
            (95, "EXIT_PROFIT", 1.03)
        ]
    },
    "BNB_M15_DCA": {
        "symbol": "BNB", "timeframe": "M15", "base_price": 320.0,
        "scenarios": [
            (8, "ENTRY_SIGNAL", 1.0),
            (15, "DCA_LAYER1_TRIGGER", 0.97),
            (22, "DCA_LAYER2_TRIGGER", 0.94),
            (30, "DCA_LAYER3_TRIGGER", 0.90),
            (45, "RECOVERY_START", 1.05),
            (65, "DCA_EXIT_PROFIT", 1.08)
        ]
    },
    "BNB_1H": {
        "symbol": "BNB", "timeframe": "1H", "base_price": 315.0,
        "scenarios": [
            (12, "MULTI_TF_CONFIRM", 1.02),
            (35, "EXIT_SIGNAL", 1.03)
        ]
    },
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # XRP - Ripple
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "XRP_M15": {
        "symbol": "XRP", "timeframe": "M15", "base_price": 0.62,
        "scenarios": [
            (12, "ENTRY_SIGNAL", 1.02),
            (40, "EXIT_PROFIT", 1.025),
            (68, "ENTRY_SIGNAL", 0.98),
            (88, "EXIT_PROFIT", 1.03)
        ]
    },
    "XRP_M15_DCA": {
        "symbol": "XRP", "timeframe": "M15", "base_price": 0.65,
        "scenarios": [
            (10, "ENTRY_SIGNAL", 1.0),
            (20, "DCA_LAYER1_TRIGGER", 0.97),
            (28, "DCA_LAYER2_TRIGGER", 0.94),
            (35, "DCA_LAYER3_TRIGGER", 0.90),
            (55, "RECOVERY_START", 1.05),
            (75, "DCA_EXIT_PROFIT", 1.08)
        ]
    },
    "XRP_1H": {
        "symbol": "XRP", "timeframe": "1H", "base_price": 0.62,
        "scenarios": [
            (15, "MULTI_TF_CONFIRM", 1.02),
            (40, "EXIT_SIGNAL", 1.03)
        ]
    },
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # AVAX - Avalanche
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "AVAX_M15": {
        "symbol": "AVAX", "timeframe": "M15", "base_price": 35.0,
        "scenarios": [
            (18, "ENTRY_SIGNAL", 1.02),
            (48, "EXIT_PROFIT", 1.025),
            (72, "ENTRY_SIGNAL", 0.98),
            (92, "EXIT_PROFIT", 1.03)
        ]
    },
    "AVAX_M15_DCA": {
        "symbol": "AVAX", "timeframe": "M15", "base_price": 36.0,
        "scenarios": [
            (12, "ENTRY_SIGNAL", 1.0),
            (22, "DCA_LAYER1_TRIGGER", 0.97),
            (30, "DCA_LAYER2_TRIGGER", 0.94),
            (38, "DCA_LAYER3_TRIGGER", 0.90),
            (52, "RECOVERY_START", 1.05),
            (72, "DCA_EXIT_PROFIT", 1.08)
        ]
    },
    "AVAX_1H": {
        "symbol": "AVAX", "timeframe": "1H", "base_price": 35.0,
        "scenarios": [
            (14, "MULTI_TF_CONFIRM", 1.02),
            (38, "EXIT_SIGNAL", 1.03)
        ]
    },
    
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # LINK - Chainlink
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "LINK_M15": {
        "symbol": "LINK", "timeframe": "M15", "base_price": 14.5,
        "scenarios": [
            (14, "ENTRY_SIGNAL", 1.02),
            (42, "EXIT_PROFIT", 1.025),
            (70, "ENTRY_SIGNAL", 0.98),
            (90, "EXIT_PROFIT", 1.03)
        ]
    },
    "LINK_M15_DCA": {
        "symbol": "LINK", "timeframe": "M15", "base_price": 15.0,
        "scenarios": [
            (10, "ENTRY_SIGNAL", 1.0),
            (20, "DCA_LAYER1_TRIGGER", 0.97),
            (28, "DCA_LAYER2_TRIGGER", 0.94),
            (36, "DCA_LAYER3_TRIGGER", 0.90),
            (54, "RECOVERY_START", 1.05),
            (74, "DCA_EXIT_PROFIT", 1.08)
        ]
    },
    "LINK_1H": {
        "symbol": "LINK", "timeframe": "1H", "base_price": 14.5,
        "scenarios": [
            (16, "MULTI_TF_CONFIRM", 1.02),
            (42, "EXIT_SIGNAL", 1.03)
        ]
    },

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    # BTC & PAXG (Market Health Only)
    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    "BTC_1H": {
        "symbol": "BTC", "timeframe": "1H", "base_price": 42000.0,
        "scenarios": [
            (10, "HEALTH_STRONG", 1.02),
            (30, "HEALTH_NEUTRAL", 1.0),
            (55, "HEALTH_WEAK", 0.97),
            (75, "HEALTH_RECOVER", 1.03)
        ]
    },
    "PAXG_1H": {
        "symbol": "PAXG", "timeframe": "1H", "base_price": 2500.0,
        "scenarios": [
            (20, "SAFE_HAVEN_STABLE", 1.005),
            (50, "SAFE_HAVEN_INFLOW", 1.01)
        ]
    }
}

def create_all_candles():
    print("=" * 60)
    print("ğŸ“Š Generating candle CSV files...")
    print("=" * 60)

    for name, cfg in CANDLE_CONFIGS.items():
        candles = generate_candles(
            cfg["symbol"],
            cfg["timeframe"],
            cfg["base_price"],
            cfg["scenarios"]
        )
        save_candles_csv(candles, f"{name}.csv")

    print("\nâœ… All candle files created!\n")
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 5: ORDERBOOK DATA
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_orderbooks():
    print("=" * 60)
    print("ğŸ“˜ Creating orderbook JSON files...")
    print("=" * 60)

    symbols = ["SOL", "BNB", "XRP", "AVAX", "LINK"]

    for sym in symbols:
        orderbook = {
            "symbol": sym,
            "bids": [[round(100 - i * 0.1, 2), 50 + i * 5] for i in range(10)],
            "asks": [[round(100 + i * 0.1, 2), 50 + i * 5] for i in range(10)],
            "spread": 0.1,
            "depth": "NORMAL",
            "timestamp": 1704067200
        }

        path = BASE_DIR / "data/orderbooks" / f"{sym}.json"
        with open(path, "w", encoding="utf-8") as f:
            json.dump(orderbook, f, indent=2)

        print(f"  âœ… Created: {path}")

    print("\nâœ… Orderbooks created!\n")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 6: SCENARIO FILES (SC-001 â†’ SC-015)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_scenarios():
    print("=" * 60)
    print("ğŸ§ª Creating scenario JSON files...")
    print("=" * 60)

    for i in range(1, 16):
        sc_id = f"SC-{i:03d}"
        scenario = {
            "scenario_id": sc_id,
            "name": f"Auto Generated Scenario {i}",
            "description": "Generated for full test framework coverage",
            "duration_candles": 100,
            "initial_wallet": "initial_wallet_v10.8.2.json",
            "candle_files": {
                "SOL": "SOL_M15.csv",
                "BNB": "BNB_M15.csv",
                "BTC": "BTC_1H.csv"
            },
            "orderbook_files": {
                "SOL": "SOL.json"
            },
            "expected_results": {
                "total_trades": i % 3 + 1,
                "winning_trades": 1,
                "final_usdt_min": 380,
                "btc_vault_increased": True
            },
            "assertions": [
                {"type": "entry_triggered", "symbol": "SOL", "candle_index": 15},
                {"type": "exit_triggered", "symbol": "SOL", "min_profit_pct": 2}
            ]
        }

        path = BASE_DIR / "data/scenarios" / f"{sc_id}.json"
        with open(path, "w", encoding="utf-8") as f:
            json.dump(scenario, f, indent=2)

        print(f"  âœ… Created: {path}")

    print("\nâœ… Scenario files created!\n")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SECTION 7: MAIN EXECUTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    create_directories()
    create_wallet()
    create_all_candles()
    create_orderbooks()
    create_scenarios()

    print("=" * 60)
    print("ğŸ‰ TEST DATA GENERATION COMPLETE")
    print("All Phase 2 test data is ready.")
    print("=" * 60)

if __name__ == "__main__":
    main()


====================
File: simple_test.py
====================
import requests
import sys

print("-" * 50)
print("ğŸ” DIAGNOSTIC MODE: Checking your connection...")

# 1. Check if VPN is changing our IP
try:
    print("   ğŸŒ Checking Internet & IP...")
    ip_info = requests.get("http://ip-api.com/json", timeout=10).json()
    print(f"   âœ… Internet OK! Your IP: {ip_info['query']}")
    print(f"   ğŸŒ Location: {ip_info['country']} (If this is Iran, VPN is OFF/Not working)")
except Exception as e:
    print(f"   âŒ Internet Check Failed: {e}")
    print("   âš ï¸ WARNING: If you have no internet, Nobitex will definitely fail.")

print("-" * 50)

# 2. Run the simple Nobitex code (Video Method)
url = "https://api.nobitex.ir/market/global-stats"
print(f"ğŸš€ Connecting to {url} ...")

try:
    # verify=False prevents SSL errors common with some VPNs
    response = requests.request("POST", url, verify=False, timeout=15)
    
    if response.status_code == 200:
        print("\nâœ… SUCCESS! (Data received):")
        print(response.text[:200] + "... (truncated)") 
    else:
        print(f"\nâŒ Connected, but server said: HTTP {response.status_code}")
        print(response.text)

except Exception as e:
    print(f"\nâŒ FAILURE: {e}")
    if "11001" in str(e):
        print("   ğŸ‘‰ CAUSE: DNS Failure. Your VPN is likely NOT tunnelling Python traffic.")
    elif "SSL" in str(e):
        print("   ğŸ‘‰ CAUSE: SSL Block. The firewall intercepted the secure connection.")


====================
File: smart_connect.py
====================
import requests
import socket
import urllib3

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def resolve_nobitex_ip():
    print("ğŸ” Attempting to resolve api.nobitex.ir IP...")
    
    # List of known Nobitex IPs (in case DNS fails completely)
    # These are ArvanCloud/Cloudflare IPs often used by Iranian sites
    backup_ips = ["185.143.233.5", "185.143.234.5", "104.26.12.16", "172.67.70.62"]
    
    try:
        # Try system DNS first
        addr_info = socket.getaddrinfo("api.nobitex.ir", 443)
        ip = addr_info[0][4][0]
        print(f"   âœ… System DNS found: {ip}")
        return ip
    except:
        print("   âš ï¸ System DNS failed. Trying manual lookup...")
        # Since we can't query DNS, let's try a direct IP bypass
        # We will use one of the backup IPs
        print(f"   ğŸ‘‰ Using Backup IP: {backup_ips[0]}")
        return backup_ips[0]

def main():
    print("-" * 50)
    print("ğŸš€ OCEAN HUNTER V6.2 â€” SMART CONNECTION")
    print("-" * 50)
    
    target_ip = resolve_nobitex_ip()
    
    # We construct a URL using the IP, but tell the server we want "api.nobitex.ir"
    url = f"https://{target_ip}/market/global-stats"
    
    headers = {
        "Host": "api.nobitex.ir",  # CRITICAL: This tells the server who we are looking for
        "User-Agent": "Mozilla/5.0",
        "Accept": "*/*"
    }
    
    print(f"ğŸ“¡ Connecting to IP: {target_ip} (Host: api.nobitex.ir)...")
    
    try:
        response = requests.post(url, headers=headers, verify=False, timeout=10)
        
        if response.status_code == 200:
            print("\n" + "="*50)
            print("âœ… SUCCESS! CONNECTION ESTABLISHED")
            print("="*50)
            print(f"Data Sample: {response.text[:200]}...")
        else:
            print(f"âŒ Server Error: HTTP {response.status_code}")
            print(response.text)
            
    except Exception as e:
        print(f"âŒ Connection Failed: {e}")
        print("   This might mean the specific IP is blocked or SSL handshake failed.")

if __name__ == "__main__":
    main()


====================
File: split_test.py
====================
import requests
import socket
import urllib3
import time

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# --- CONFIG ---
PROXY_URL = "http://127.0.0.1:10809"  # Found in V6.4
NOBITEX_URL = "https://api.nobitex.ir/market/global-stats"
GOOGLE_CHECK = "https://www.google.com"

def test_direct_nobitex():
    print("\n[1] TESTING DIRECT CONNECTION TO NOBITEX (IRAN IP)...")
    session = requests.Session()
    session.trust_env = False  # IGNORE System Proxies
    
    # 1. Try standard DNS
    try:
        print("   ğŸ‘‰ Attempting standard connection (No Proxy)...")
        resp = session.post(NOBITEX_URL, verify=False, timeout=5)
        if resp.status_code == 200:
            print("   âœ… SUCCESS! Direct connection works.")
            return True
        else:
            print(f"   âŒ HTTP Error: {resp.status_code}")
    except Exception as e:
        print(f"   âŒ Standard Connection Failed: {e}")

    # 2. Try Manual IP (DNS Bypass) if step 1 failed
    print("   ğŸ‘‰ Attempting Direct IP Bypass (104.26.12.16)...")
    try:
        headers = {"Host": "api.nobitex.ir"}
        # Cloudflare IP often used by Nobitex
        resp = session.post("https://104.26.12.16/market/global-stats", headers=headers, verify=False, timeout=5)
        if resp.status_code == 200:
            print("   âœ… SUCCESS! Direct IP works.")
            print("   â„¹ï¸  NOTE: We might need to use this IP in the main code.")
            return True
        else:
            print(f"   âŒ IP Bypass HTTP Error: {resp.status_code}")
    except Exception as e:
        print(f"   âŒ IP Bypass Failed: {e}")
    
    return False

def test_proxy_foreign():
    print("\n[2] TESTING PROXY CONNECTION FOR MEXC/TELEGRAM...")
    proxies = {"http": PROXY_URL, "https": PROXY_URL}
    
    try:
        print(f"   ğŸ‘‰ Connecting to Google/MEXC via {PROXY_URL}...")
        resp = requests.get(GOOGLE_CHECK, proxies=proxies, verify=False, timeout=10)
        if resp.status_code == 200:
            print("   âœ… SUCCESS! Proxy is working for foreign sites.")
            return True
        else:
            print(f"   âŒ Proxy HTTP Error: {resp.status_code}")
    except Exception as e:
        print(f"   âŒ Proxy Failed: {e}")
        print("   âš ï¸ Ensure V2RayN is RUNNING.")
    
    return False

def main():
    print("-" * 50)
    print("ğŸš€ OCEAN HUNTER V6.5 â€” SPLIT TUNNEL TEST")
    print("-" * 50)
    
    nobitex_ok = test_direct_nobitex()
    proxy_ok = test_proxy_foreign()

    print("\n" + "="*50)
    print("ğŸ“Š FINAL DIAGNOSIS & ACTION PLAN")
    print("="*50)

    if nobitex_ok and proxy_ok:
        print("âœ… PERFECT SCENARIO!")
        print("   We will configure the bot to:")
        print("   1. Use NO PROXY for Nobitex.")
        print("   2. Use PROXY (10809) for Telegram/MEXC.")
    elif not nobitex_ok:
        print("âš ï¸ NOBITEX ISSUE:")
        print("   Your ISP is blocking Nobitex DNS or IP.")
        print("   We may need to hardcode the IP in the bot.")
    elif not proxy_ok:
        print("âš ï¸ PROXY ISSUE:")
        print("   V2RayN is not responding on port 10809.")

if __name__ == "__main__":
    main()


====================
File: state.json
====================
{
    "positions": {},
    "pending_queue": [],
    "last_heartbeat": null,
    "total_profit_usdt": 0,
    "btc_accumulated": 0,
    "paxg_accumulated": 0
}


====================
File: test_exchange.py
====================
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# test_exchange.py â€” ØªØ³Øª Ø§ØªØµØ§Ù„ ØµØ±Ø§ÙÛŒ + Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ ØªÙ„Ú¯Ø±Ø§Ù…
# Reference: EXCHANGE-TEST-093
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import os
import sys
from datetime import datetime

# Add project root to path
PROJECT_ROOT = os.path.dirname(os.path.abspath(__file__))
if PROJECT_ROOT not in sys.path:
    sys.path.insert(0, PROJECT_ROOT)

def main():
    print("=" * 60)
    print("ğŸŒŠ OCEAN HUNTER â€” Exchange Connection Test")
    print(f"â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print("=" * 60)
    
    # â•â•â• Step 1: Connect to MEXC â•â•â•
    print("\n[1] Connecting to MEXC...")
    
    try:
        from modules.network.mexc_api import get_client
        client = get_client()
        
        # Ping test
        ping = client.ping()
        if "error" in ping:
            print(f"   âŒ Ping Failed: {ping}")
            return
        print("   âœ… Connected to MEXC!")
        
    except Exception as e:
        print(f"   âŒ Connection Error: {e}")
        return
    
    # â•â•â• Step 2: Get Top Crypto Prices â•â•â•
    print("\n[2] Fetching Crypto Prices...")
    
    symbols = ["BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "XRPUSDT", 
               "ADAUSDT", "DOGEUSDT", "TRXUSDT", "TONUSDT", "SHIBUSDT"]
    
    prices = {}
    for symbol in symbols:
        try:
            result = client.get_ticker_price(symbol)
            if "price" in result:
                price = float(result["price"])
                prices[symbol] = price
                coin = symbol.replace("USDT", "")
                print(f"   ğŸ’° {coin}: ${price:,.4f}")
            else:
                print(f"   âš ï¸ {symbol}: No price data")
        except Exception as e:
            print(f"   âŒ {symbol}: {e}")
    
    # â•â•â• Step 3: Get Account Balance â•â•â•
    print("\n[3] Checking Account Balance...")
    
    balances = []
    try:
        account = client.get_account()
        if "balances" in account:
            print("   âœ… Authentication Successful!")
            
            # Find non-zero balances
            for b in account["balances"]:
                free = float(b.get("free", 0))
                locked = float(b.get("locked", 0))
                if free > 0 or locked > 0:
                    asset = b["asset"]
                    total = free + locked
                    balances.append({"asset": asset, "free": free, "locked": locked, "total": total})
                    print(f"   ğŸ’µ {asset}: {free:.6f} (locked: {locked:.6f})")
            
            if not balances:
                print("   ğŸ“­ No assets found (empty account)")
        else:
            print(f"   âš ï¸ Account response: {account}")
            
    except Exception as e:
        print(f"   âŒ Balance Error: {e}")
    
    # â•â•â• Step 4: Build Report â•â•â•
    print("\n[4] Building Report...")
    
    report = "ğŸŒŠ <b>OCEAN HUNTER â€” Market Report</b>\n"
    report += f"ğŸ“… {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
    report += "â”€" * 25 + "\n\n"
    
    # Prices section
    report += "ğŸ“Š <b>Top 10 Crypto Prices:</b>\n"
    for symbol, price in prices.items():
        coin = symbol.replace("USDT", "")
        if price >= 1000:
            report += f"   â€¢ {coin}: <code>${price:,.2f}</code>\n"
        elif price >= 1:
            report += f"   â€¢ {coin}: <code>${price:.4f}</code>\n"
        else:
            report += f"   â€¢ {coin}: <code>${price:.8f}</code>\n"
    
    report += "\n"
    
    # Balance section
    if balances:
        report += "ğŸ’¼ <b>Your Balances:</b>\n"
        for b in balances[:10]:  # Max 10
            report += f"   â€¢ {b['asset']}: <code>{b['free']:.6f}</code>\n"
    else:
        report += "ğŸ’¼ <b>Balances:</b> No assets\n"
    
    report += "\nâœ… <i>Connection Test Successful!</i>"
    
    print("   âœ… Report Ready!")
    
    # â•â•â• Step 5: Send to Telegram â•â•â•
    print("\n[5] Sending to Telegram...")
    
    try:
        from modules.network.telegram_bot import get_bot
        bot = get_bot()
        
        # Test connection first
        if not bot.test_connection():
            print("   âŒ Bot connection failed!")
            return
        
        # Send report
        result = bot.send_message(report)
        
        if result.get("ok"):
            print("   âœ… Report sent to Telegram!")
            print("\n" + "=" * 60)
            print("ğŸ‰ ALL TESTS PASSED!")
            print("=" * 60)
        else:
            print(f"   âŒ Send failed: {result}")
            
    except Exception as e:
        print(f"   âŒ Telegram Error: {e}")

if __name__ == "__main__":
    main()


====================
File: test_telegram_conn.py
====================

import os
import requests
import sys
from dotenv import load_dotenv

load_dotenv()

TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

print("-" * 60)
print("ğŸ“¡ TELEGRAM CONNECTIVITY TEST (SMART PROXY)")
print("-" * 60)

if not TOKEN or not CHAT_ID:
    print("âŒ ERROR: TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID missing.")
    sys.exit(1)

# List of common local proxies used by V2Ray, NekoBox, Clash, etc.
# We will try them one by one.
POTENTIAL_PROXIES = [
    None,                           # Try Direct first (might work if VPN is in TUN mode)
    "http://127.0.0.1:10809",       # V2Ray Default HTTP
    "socks5://127.0.0.1:10808",     # V2Ray Default SOCKS
    "http://127.0.0.1:2081",        # NekoBox/Hiddify HTTP
    "socks5://127.0.0.1:2080",      # NekoBox/Hiddify SOCKS
    "http://127.0.0.1:7890",        # Clash Default
    "socks5://127.0.0.1:7891",      # Clash SOCKS
    "http://127.0.0.1:1080",        # Generic Proxy
]

working_proxy = None
bot_username = ""

print(f"ğŸ”¹ Token: {TOKEN[:5]}...{TOKEN[-5:]}")
print(f"ğŸ”¹ Checking {len(POTENTIAL_PROXIES)} connection methods...")

# 1. FIND WORKING PROXY
for proxy_url in POTENTIAL_PROXIES:
    proxies_dict = {"https": proxy_url, "http": proxy_url} if proxy_url else None
    label = proxy_url if proxy_url else "DIRECT CONNECTION"
    
    print(f"\n   ğŸ‘‰ Trying: {label} ... ", end="")
    try:
        url = f"https://api.telegram.org/bot{TOKEN}/getMe"
        resp = requests.get(url, proxies=proxies_dict, timeout=5)
        
        if resp.status_code == 200:
            print("âœ… SUCCESS!")
            working_proxy = proxies_dict
            data = resp.json()
            bot_username = data['result']['username']
            print(f"      ğŸ‰ Connected to Bot: @{bot_username}")
            break
        else:
            print(f"âŒ Failed (HTTP {resp.status_code})")
    except Exception as e:
        print("âŒ Failed (Timeout/Error)")

if not working_proxy and not bot_username:
    print("\n" + "="*60)
    print("âŒ CRITICAL: ALL CONNECTION ATTEMPTS FAILED.")
    print("   Please check your V2Ray/VPN settings.")
    print("   Look for 'Local Port' or 'HTTP Proxy Port' in your VPN app.")
    print("   Common ports: 10809, 2081, 7890")
    print("="*60)
    sys.exit(1)

# 2. SEND MESSAGE
print(f"\n[2] Sending Test Message using found path...")
try:
    msg = f"ğŸ”” OCEAN HUNTER: Connection Successful!\nğŸš€ Proxy used: {working_proxy if working_proxy else 'Direct'}"
    url = f"https://api.telegram.org/bot{TOKEN}/sendMessage"
    payload = {"chat_id": CHAT_ID, "text": msg}
    
    resp = requests.post(url, json=payload, proxies=working_proxy, timeout=10)
    data = resp.json()
    
    if data.get("ok"):
        print("   âœ… MESSAGE SENT SUCCESSFULLY!")
        print("   ğŸ‘‰ Check your Telegram app now.")
        
        # Save working proxy to .env for future use (Optional logic could go here)
        print(f"   â„¹ï¸  To make this permanent, you might need to set HTTPS_PROXY in .env")
        if working_proxy:
             print(f"       Example: HTTPS_PROXY={working_proxy['https']}")
    else:
        print(f"   âŒ Send Failed: {data}")

except Exception as e:
    print(f"   âŒ Error sending message: {e}")

print("-" * 60)


====================
File: Ai_Tools\ARCHITECTURE.txt
====================
################################################################################
#                    OCEAN HUNTER V10.8.2 â€” COMPLETE SECURE ARCHITECTURE       #
#           SPOT SWING TRADING | 5 ALTCOINS â†’ BTC + PAXG ACCUMULATION          #
#                     Date: 1404/10/09 | 2025-12-30                            #
#                                                                              #
#   STATUS: FINAL & LOCKED | CAPITAL: PERCENTAGE-BASED | SECURITY: MAXIMUM    #
#   REFERENCE: REF-ARCH-V10.8.2-FINAL-LOCK-610                                 #
################################################################################

================================================================================
SECTION 1 â€” CAPITAL ALLOCATION & ASSET ROLES
================================================================================

[1.1] Capital Model: PERCENTAGE-BASED (Scalable)
    - Minimum Required: 500 USDT
    - No Maximum Limit
    - All calculations use percentages, not fixed amounts

[1.2] Asset Allocation Table:

    +------------+---------+---------------------------------------------+
    | Asset      | Percent | Role                                        |
    +------------+---------+---------------------------------------------+
    | SOL        | 25%     | Primary Swing Target                        |
    | BNB        | 20%     | Secondary Swing Target                      |
    | XRP        | 15%     | Tertiary Swing Target                       |
    | AVAX       | 10%     | Opportunity Target                          |
    | LINK       | 10%     | Opportunity Target                          |
    | USDT       | 10%     | Operating Reserve (DCA Fuel)                |
    | BTC        | 5%      | Growth Vault (Profit Destination)           |
    | PAXG       | 5%      | Smart Vault (Safe Haven + Refuel)           |
    +------------+---------+---------------------------------------------+
    | TOTAL      | 100%    |                                             |
    +------------+---------+---------------------------------------------+

[1.3] Golden Flow of Capital:

    USDT --> Buy Altcoin --> Sell with Profit --> Profit Router --> BTC/PAXG
                          --> Principal returns to USDT Pool

[1.4] Core Safety Rules:

    [X] NO STOP-LOSS (DCA replaces cutting losses)
    [X] NO LEVERAGE (Spot only)
    [X] NO ETH (Focus on faster alts)
    [V] PAXG = Last line of defense (Emergency Refuel)

================================================================================
SECTION 2 â€” STRATEGY LOGIC: SMART SNIPER
================================================================================

[2.1] Timeframes:
    - Analysis: M15 (candle close)
    - Safety Checks: Real-time / 60s

[2.2] Entry Logic (Score >= 70 to Enter):

    +--------------------+------------------------------------+--------+
    | Factor             | Condition                          | Points |
    +--------------------+------------------------------------+--------+
    | Technical          | RSI(14) < 35 AND Price < BB_Lower  | 35     |
    | Order Book (OBI)   | Bid Volume > Ask Volume (Top 20)   | 15     |
    | Volume Spike       | Volume > 1.5 x SMA(20)             | 25     |
    | Momentum           | Green Candle (Close > Open)        | 25     |
    +--------------------+------------------------------------+--------+
    | TOTAL POSSIBLE     |                                    | 100    |
    +--------------------+------------------------------------+--------+

    NOTE: OBI weight reduced to 15 (was 30) due to Nobitex manipulation risk

[2.3] Exit Logic:
    - Take Profit: 1.5% - 3% (Dynamic based on momentum)
    - Trailing Stop: Activates after +1% profit

[2.4] DCA Layers (If Position Goes Against):

    +-------+---------------+----------------+-----------------+
    | Layer | Trigger       | Add Amount     | New Avg Target  |
    +-------+---------------+----------------+-----------------+
    | L1    | -3% from Avg  | +50% Position  | Reduce by ~1.5% |
    | L2    | -6% from Avg  | +75% Position  | Reduce by ~2.5% |
    | L3    | -10% from Avg | +100% Position | Reduce by ~4%   |
    +-------+---------------+----------------+-----------------+

[2.5] NOBITEX API SPECIFICATIONS:

    [2.5.1] Rate Limits:
        - Private API: 30 requests/minute (HARD LIMIT)
        - Implementation: Use 25 req/min with 2.5s spacing

    [2.5.2] Order Constraints:
        - Minimum Order: 10 USDT (Use 12 USDT buffer)
        - Order Types: "limit" and "market" ONLY
        - Precision: Fetch dynamically from GET /v2/options

    [2.5.3] Fee Structure:
        - Taker Fee: 0.35%
        - Maker Fee: 0.25%
        - Use 0.35% in all calculations (worst case)

    [2.5.4] Key Endpoints:

        +-----------------------------+----------------------------------+
        | Endpoint                    | Purpose                          |
        +-----------------------------+----------------------------------+
        | GET /v2/wallets             | Fetch all balances               |
        | GET /v2/orderbook/{symbol}  | Order book for OBI calculation   |
        | GET /v2/trades/{symbol}     | Recent trades                    |
        | POST /market/orders/add     | Place new order                  |
        | POST /market/orders/cancel  | Cancel existing order            |
        | GET /v2/options             | Trading pairs info (precision)   |
        | GET /market/udf/history     | OHLCV candle data                |
        +-----------------------------+----------------------------------+

    [2.5.5] Authentication:
        - Header: Authorization: Token {API_KEY}

[2.6] POSITION LIMITS & QUEUE SYSTEM:

    [2.6.1] Concurrent Position Limit:
        MAX_CONCURRENT_POSITIONS = 3

    [2.6.2] Queue Management:
        - Signals scoring >= 70 but blocked â†’ Add to WAITING_QUEUE
        - Queue stores: {symbol, score, timestamp, price_at_signal}
        - Queue Expiry: 4 HOURS (signal becomes stale)
        - Max Queue Size: 5 signals

    [2.6.3] Queue Processing:
        WHEN position closes:
            CHECK WAITING_QUEUE
            FOR each queued signal (oldest first):
                IF not expired AND current_price <= price_at_signal * 1.01:
                    RE-EVALUATE score
                    IF score >= 70: EXECUTE
                ELSE:
                    DISCARD signal

    [2.6.4] Overexposure Protection:
        IF all 3 slots filled AND new signal score >= 85:
            LOG "High-conviction signal blocked"
            ALERT via Telegram
            ADD to priority queue

[2.7] BTC TREND FILTER (Entry Gate):

    BEFORE any new entry:
        CHECK BTC_HEALTH (from Section 3.1)
        IF BTC_HEALTH == "WEAK":
            BLOCK new entries completely
            LOG "Entry blocked: BTC in WEAK state"
            ALERT via Telegram
        IF BTC_HEALTH == "NEUTRAL" or "STRONG":
            ALLOW entry evaluation

[2.8] ORDER EXECUTION STRATEGY:

    [2.8.1] Primary Method: LIMIT ORDER
        - Price: Current price + 0.1% (for BUY)
        - Price: Current price - 0.1% (for SELL)
        - Timeout: 30 seconds

    [2.8.2] Fallback Method: MARKET ORDER
        IF Limit order not filled in 30 seconds:
            CANCEL limit order
            PLACE market order
            LOG "Fallback to market order"

    [2.8.3] Benefits:
        - Reduced slippage
        - Lower fees (Maker vs Taker)
        - Protection against price manipulation

================================================================================
SECTION 3 â€” PROFIT ROUTER V2.0 (DYNAMIC BTC/PAXG SPLIT)
================================================================================

[3.1] BTC Health Assessment (1H Timeframe):
    - Indicators: RSI(14), EMA(50), MACD(12,26,9)

    BTC_STRONG  = RSI > 60 AND Price > EMA(50) AND MACD > 0
    BTC_WEAK    = RSI < 40 AND Price < EMA(50) AND MACD < 0
    BTC_NEUTRAL = Everything else

[3.2] Profit Distribution Rules:

    +------------------+-----------------+-----------------+
    | BTC State        | To BTC Vault    | To PAXG Vault   |
    +------------------+-----------------+-----------------+
    | STRONG           | 80%             | 20%             |
    | NEUTRAL          | 50%             | 50%             |
    | WEAK             | 20%             | 80%             |
    +------------------+-----------------+-----------------+

[3.3] Profit Flow Example (100 USDT profit, NEUTRAL state):
    â†’ 50 USDT â†’ Buy BTC â†’ BTC Vault
    â†’ 50 USDT â†’ Buy PAXG â†’ PAXG Vault

================================================================================
SECTION 4 â€” EMERGENCY REFUEL PROTOCOL (PAXG â†’ USDT)
================================================================================

[4.1] Activation Conditions (ALL must be true):
    - DCA Layer 3 is active
    - USDT Pool < 20% of allocated slot capital
    - PAXG position is in PROFIT
    - Global Stop is NOT active

[4.2] Execution Limits:
    - Maximum sell: 50% of PAXG holdings
    - Cooldown: 24 hours between refuels

[4.3] WAIT MODE:
    IF PAXG is at loss when needed:
        PAUSE DCA execution
        WAIT for PAXG recovery
        ALERT "Waiting for PAXG profit to refuel"

[4.4] Refuel Flow:
    PAXG (profit) â†’ Sell 50% â†’ USDT â†’ Fund DCA Layer 3

================================================================================
SECTION 5 â€” WATCHDOG BELLE (System Health Monitor)
================================================================================

[5.1] Check Interval: Every 60 seconds

[5.2] Health Checks:

    +-----+---------------------------+------------------+------------------+
    | #   | Check                     | Warning          | Critical         |
    +-----+---------------------------+------------------+------------------+
    | 1   | API Response Time         | > 5 seconds      | > 10 seconds     |
    | 2   | Balance Sync              | > 1% mismatch    | > 5% mismatch    |
    | 3   | Position Drift            | > 2% from state  | > 5% from state  |
    | 4   | Memory Usage              | > 70%            | > 90%            |
    | 5   | Open Order Age            | > 30 minutes     | > 60 minutes     |
    | 6   | Last Successful Trade     | > 24 hours       | > 72 hours       |
    +-----+---------------------------+------------------+------------------+

[5.3] Actions:
    - Warning: Log + Continue
    - Critical: Log + Alert + Consider HALT

[5.4] External Heartbeat:
    - Send Telegram message every 30 MINUTES
    - Message includes: Status, Open Positions, USDT Balance, BTC Health
    - If no heartbeat received â†’ System may be down

================================================================================
SECTION 6 â€” TELEGRAM INTEGRATION
================================================================================

[6.1] Alert Levels:

    +----------+-------------------+----------------------------------------+
    | Level    | Emoji             | Use Case                               |
    +----------+-------------------+----------------------------------------+
    | INFO     | â„¹ï¸                | Trade opened, closed, status updates   |
    | WARNING  | âš ï¸                | DCA triggered, queue full, anomaly     |
    | CRITICAL | ğŸš¨                | Global stop, kill switch, system halt  |
    | SUCCESS  | âœ…                | Profitable trade, vault deposit        |
    +----------+-------------------+----------------------------------------+

[6.2] Commands:

    /status     â†’ Current positions, balances, mode
    /stop       â†’ Activate Global Stop
    /restart    â†’ Begin recovery protocol
    /report     â†’ Daily summary
    /mode       â†’ Show current trading mode
    /queue      â†’ Show waiting queue status
    /health     â†’ Show BTC health state

[6.3] Connection:
    - Use SOCKS5 proxy (127.0.0.1:1080) for Iran
    - Retry logic: 3 attempts with 5s delay
    - Fallback: Log locally if Telegram fails

[6.4] Security:
    - WHITELIST_CHAT_IDS: Only your chat ID allowed
    - Rate limit commands: 1 per 5 seconds
    - Critical commands require /confirm within 30 seconds

================================================================================
SECTION 7 â€” DATA FLOW DIAGRAM
================================================================================

    +------------------+
    |   Nobitex API    |
    +--------+---------+
             |
             v
    +--------+---------+
    |   Rate Limiter   | (25 req/min, 2.5s spacing)
    +--------+---------+
             |
             v
    +--------+---------+
    |  Data Processor  | (Candles, Order Book, Balances)
    +--------+---------+
             |
    +--------+--------+--------+
    |        |        |        |
    v        v        v        v
+-------+ +------+ +------+ +--------+
|Spread | |Wick  | |Volume| |Indicators|
|Filter | |Filter| |Check | |(RSI,BB) |
+---+---+ +--+---+ +--+---+ +----+----+
    |        |        |          |
    +--------+--------+----------+
             |
             v
    +--------+---------+
    |  Strategy Engine | (Score calculation)
    +--------+---------+
             |
             v
    +--------+---------+
    | Position Manager | (Max 3 + Queue)
    +--------+---------+
             |
             v
    +--------+---------+
    |  Order Executor  | (Limit first, Market fallback)
    +--------+---------+
             |
             v
    +--------+---------+
    |  Profit Router   | (BTC/PAXG split)
    +--------+---------+
             |
             v
    +--------+---------+
    |  State Manager   | (state.json + backup)
    +--------+---------+
             |
             v
    +--------+---------+
    |    Telegram      | (Alerts + Heartbeat)
    +------------------+
================================================================================
SECTION 8 â€” DIRECTORY STRUCTURE
================================================================================

OCEAN_HUNTER/
â”œâ”€â”€ main.py                     # Entry point + main loop
â”œâ”€â”€ config.py                   # All parameters & thresholds
â”œâ”€â”€ requirements.txt            # Python dependencies
â”œâ”€â”€ state.json                  # Persistent state (positions, balances)
â”œâ”€â”€ trades.xlsx                 # Trade history log
â”œâ”€â”€ .env                        # API keys (NEVER commit!)
â”œâ”€â”€ .gitignore                  # Git ignore rules
â”‚
â”œâ”€â”€ Ai_Tools/                   # AI Development Toolkit
â”‚   â”œâ”€â”€ setup_git.py            # Git repository initializer
â”‚   â”œâ”€â”€ build.py                # Auto-build script
â”‚   â”œâ”€â”€ context_gen.py          # Project context generator
â”‚   â”œâ”€â”€ WORKFLOW.txt            # Automation rules
â”‚   â””â”€â”€ ARCHITECTURE.txt        # This document (V10.8.2)
â”‚
â”œâ”€â”€ modules/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ engine.py           # Main trade cycle manager
â”‚   â”‚   â”œâ”€â”€ config_loader.py    # Load config & .env
â”‚   â”‚   â”œâ”€â”€ rate_limiter.py     # API rate limiting (25 req/min)
â”‚   â”‚   â”œâ”€â”€ state_manager.py    # Read/Write state.json + backup
â”‚   â”‚   â””â”€â”€ safety_manager.py   # Kill switch, mode gates, drawdown
â”‚   â”‚
â”‚   â”œâ”€â”€ network/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ nobitex.py          # Exchange API wrapper
â”‚   â”‚   â””â”€â”€ telegram.py         # Alerts with SOCKS5 proxy
â”‚   â”‚
â”‚   â”œâ”€â”€ analysis/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ indicators.py       # RSI, EMA, BB, MACD, ATR
â”‚   â”‚   â”œâ”€â”€ orderflow.py        # OBI calculation
â”‚   â”‚   â””â”€â”€ btc_health.py       # BTC state assessment
â”‚   â”‚
â”‚   â”œâ”€â”€ trading/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ strategy.py         # Entry/Exit scoring
â”‚   â”‚   â”œâ”€â”€ dca_manager.py      # DCA layers + WAIT MODE
â”‚   â”‚   â”œâ”€â”€ profit_router.py    # BTC/PAXG distribution
â”‚   â”‚   â”œâ”€â”€ position_manager.py # Max 3 positions + Queue [NEW V10.8]
â”‚   â”‚   â””â”€â”€ refuel.py           # Emergency PAXG liquidation
â”‚   â”‚
â”‚   â”œâ”€â”€ security/               # [NEW V10.8.2]
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ spread_filter.py    # Abnormal spread detection
â”‚   â”‚   â”œâ”€â”€ wick_filter.py      # Fake candle neutralizer
â”‚   â”‚   â”œâ”€â”€ volume_sanity.py    # Wash trade detection
â”‚   â”‚   â””â”€â”€ order_lock.py       # Race condition prevention
â”‚   â”‚
â”‚   â””â”€â”€ watchdog/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ belle.py            # 60s health monitor + 30min heartbeat
â”‚
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ candles_cache/          # Cached OHLCV data
â”‚   â”œâ”€â”€ state_backups/          # Rolling 10 backups [NEW V10.8.2]
â”‚   â””â”€â”€ logs/                   # Daily log files
â”‚
â””â”€â”€ context_backups/            # Auto-generated context snapshots

================================================================================
SECTION 9 â€” REPORTING (trades.xlsx)
================================================================================

[9.1] Trade Log Columns:

    +-----+-------------------+------------------------------------------------+
    | #   | Column Name       | Description                                    |
    +-----+-------------------+------------------------------------------------+
    | 1   | trade_id          | Unique identifier (UUID)                       |
    | 2   | timestamp         | Trade execution time                           |
    | 3   | symbol            | Trading pair (e.g., SOLUSDT)                   |
    | 4   | side              | BUY or SELL                                    |
    | 5   | entry_price       | Average entry price                            |
    | 6   | exit_price        | Exit price (if closed)                         |
    | 7   | quantity          | Amount traded                                  |
    | 8   | pnl_usdt          | Profit/Loss in USDT                            |
    | 9   | pnl_percent       | Profit/Loss percentage                         |
    | 10  | dca_layer         | DCA level used (0-3)                           |
    | 11  | profit_destination| Where profit went (BTC/PAXG/BOTH)              |
    | 12  | btc_health_state  | BTC state at profit time                       |
    | 13  | paxg_action       | HOLD/REFUEL/NONE                               |
    | 14  | emergency_refuel  | TRUE/FALSE (was PAXG used for rescue)          |
    | 15  | fees_paid         | Total fees in USDT                             |
    | 16  | duration_minutes  | Time from entry to exit                        |
    | 17  | score_at_entry    | Strategy score when entered                    |
    | 18  | queue_wait_time   | Minutes waited in queue (0 if immediate) [NEW] |
    | 19  | security_flags    | Any filters triggered (spread/wick/volume)[NEW]|
    | 20  | notes             | Auto-generated trade notes                     |
    +-----+-------------------+------------------------------------------------+

[9.2] Daily Summary Sheet:

    - Total trades executed
    - Win rate percentage
    - Net PnL (USDT)
    - BTC vault growth
    - PAXG vault growth
    - Max drawdown reached
    - API calls made
    - Queue utilization (signals queued vs executed) [NEW V10.8]
    - Security blocks count (spread/wick/volume) [NEW V10.8.2]

================================================================================
SECTION 10 â€” GLOBAL STOP PROTOCOL
================================================================================

[10.1] Activation Conditions (ANY triggers STOP):

    +-----+----------------------------------+----------------------------------+
    | #   | Condition                        | Detection Method                 |
    +-----+----------------------------------+----------------------------------+
    | 1   | BTC drops > 8% in 4 hours        | Price monitoring (1H candles)    |
    | 2   | Portfolio drawdown > 15%         | Real-time balance check          |
    | 3   | API failure > 60 seconds         | Health check timeout             |
    | 4   | Manual STOP command              | Telegram /stop command           |
    | 5   | Balance mismatch > 5%            | Local vs Exchange comparison     |
    | 6   | State file corruption            | Checksum validation [NEW V10.8.2]|
    +-----+----------------------------------+----------------------------------+

[10.2] STOP Actions:

    1. Cancel ALL open orders immediately
    2. Set system state to HALTED
    3. Send CRITICAL alert to Telegram
    4. Log all current positions and balances
    5. Clear WAITING_QUEUE [NEW V10.8]
    6. Require manual restart with confirmation

[10.3] Recovery Protocol:

    1. User sends /restart command
    2. System performs full health check
    3. Compares state.json with exchange data
    4. Validates state.json checksum [NEW V10.8.2]
    5. If mismatch found â†’ require manual resolution
    6. If clean â†’ resume in EXIT_ONLY mode for 1 hour
    7. After 1 hour with no issues â†’ resume NORMAL mode

================================================================================
SECTION 11 â€” SECURITY PROTOCOLS (HARDENED)
================================================================================

[11.1] Trading Mode Gates (MANDATORY PROGRESSION):

    +------------+------------------+-------------------------------------------+
    | Mode       | Duration         | Restrictions                              |
    +------------+------------------+-------------------------------------------+
    | PAPER      | Min 72 hours     | NO real orders, simulation only           |
    | LIVE_TEST  | Min 7 days       | Max 50 USDT total exposure                |
    | LIVE_FULL  | After approval   | Full capital with all safety checks       |
    +------------+------------------+-------------------------------------------+

    Mode Transition Rules:
    - PAPER â†’ LIVE_TEST: Requires 72h runtime + manual approval
    - LIVE_TEST â†’ LIVE_FULL: Requires 7 days + positive PnL + manual approval
    - Any mode can go back to PAPER instantly

[11.2] Hardware Kill Switch:

    Activation Triggers:
    - Internet disconnection > 30 seconds
    - API unresponsive > 60 seconds
    - System memory > 90%
    - Unexpected exception in main loop

    Kill Actions:
    - Immediately terminate all processes
    - Do NOT attempt order cancellation (may fail)
    - Write emergency state dump to disk
    - Send offline alert via backup channel (if possible)

[11.3] Request Rate Limiter:

    Configuration:
    - Hard limit: 25 requests per minute (below Nobitex 30)
    - Minimum spacing: 2.5 seconds between requests
    - Queue overflow action: REJECT and ALERT

    Implementation:
    - Token bucket algorithm
    - Separate queues for: Orders, Balance, Market Data
    - Priority: Orders > Balance > Market Data

[11.4] Balance Sanity Checker:

    Pre-Order Verification:
    1. Fetch fresh balance from exchange
    2. Compare with local state.json
    3. If difference > 5% â†’ HALT + ALERT
    4. If difference 1-5% â†’ WARNING + Continue
    5. If difference < 1% â†’ OK

    Post-Order Verification:
    1. Wait 3 seconds after order
    2. Fetch updated balance
    3. Verify expected change occurred
    4. Log discrepancy if any

[11.5] Maximum Drawdown Protection:

    Threshold: 15% of initial portfolio value

    Monitoring:
    - Check every 60 seconds (via Watchdog)
    - Calculate: (Initial_Value - Current_Value) / Initial_Value

    Action on Breach:
    1. Immediate GLOBAL STOP
    2. Cancel all open orders
    3. Send CRITICAL alert with full report
    4. Require manual intervention to restart
    5. Log incident with timestamp and portfolio snapshot

[11.6] API Key Security:

    Storage:
    - .env file with 600 permissions (owner read/write only)
    - Never logged, never in error messages
    - Never committed to git (.gitignore enforced)

    Runtime:
    - Load once at startup
    - Store in memory only
    - Clear on shutdown

    Exchange Panel Settings [NEW V10.8.2]:
    - [X] IP Whitelist: SERVER_IP_ONLY
    - [X] Permissions: Trade + Read
    - [ ] Withdrawal: DISABLED (CRITICAL!)

[11.7] Audit Trail:

    All Actions Logged:
    - Every API request with timestamp
    - Every order placed/cancelled
    - Every state change
    - Every alert sent
    - Every mode transition
    - Every security filter trigger [NEW V10.8.2]

    Log Retention:
    - Daily rotation
    - 30 days local storage
    - Critical events: permanent

[11.8] Anti-Manipulation Filters [NEW V10.8.2]:

    [11.8.1] Spread Filter:
        MAX_SPREAD_PERCENT = 0.005 (0.5%)
        
        Logic:
            spread = (best_ask - best_bid) / best_bid
            IF spread > MAX_SPREAD_PERCENT:
                BLOCK entry
                LOG "Abnormal spread detected"
                ALERT (WARNING)

    [11.8.2] Wick Filter:
        Logic:
            candle_body = |close - open|
            candle_wick = (high - low) - candle_body
            IF candle_wick > 3 Ã— candle_body:
                IGNORE current candle
                USE previous candle for indicators
                LOG "Abnormal wick ignored"

    [11.8.3] Volume Sanity Check:
        Logic:
            avg_volume = SMA(volume, 20)
            IF current_volume > 10 Ã— avg_volume:
                FLAG as SUSPICIOUS
                REDUCE position size by 50%
                ALERT (INFO)

    [11.8.4] Order Duplication Lock:
        ORDER_LOCK = GLOBAL MUTEX
        MIN_ORDER_INTERVAL = 5 seconds
        
        Logic:
            BEFORE placing order:
                ACQUIRE ORDER_LOCK
                IF last_order_time < 5 seconds:
                    CANCEL placement
                    LOG "Duplicate order prevented"
            AFTER placement:
                RELEASE ORDER_LOCK

    [11.8.5] State File Protection:
        - Backup state.json every 5 minutes
        - Keep last 10 backups (rolling)
        - Validate checksum on load
        - AUTO-RESTORE if corruption detected
        - Start in EXIT_ONLY mode after restore

    [11.8.6] Security Boundary Principle:
        Security filters NEVER:
            - Modify strategy logic
            - Modify scoring weights
            - Force entries
        
        They ONLY:
            - BLOCK execution
            - REDUCE size
            - DELAY execution
        
        Strategy purity is preserved.

================================================================================
SECTION 12 â€” CONFIGURATION REFERENCE (config.py)
================================================================================

[12.1] Capital Settings:

    # PERCENTAGE-BASED (V10.8+)
    MIN_CAPITAL_USDT = 500
    
    ALLOCATION = {
        "SOL": 0.25,
        "BNB": 0.20,
        "XRP": 0.15,
        "AVAX": 0.10,
        "LINK": 0.10,
        "USDT": 0.10,
        "BTC": 0.05,
        "PAXG": 0.05
    }

[12.2] Trading Parameters:

    MIN_ORDER_USDT = 12
    ENTRY_SCORE_THRESHOLD = 70
    TAKE_PROFIT_MIN = 0.015
    TAKE_PROFIT_MAX = 0.030
    TRAILING_ACTIVATION = 0.01
    
    # Order Execution (V10.8.1+)
    ORDER_TYPE_PRIMARY = "limit"
    LIMIT_ORDER_OFFSET = 0.001  # 0.1%
    LIMIT_ORDER_TIMEOUT = 30   # seconds
    ORDER_TYPE_FALLBACK = "market"

[12.3] Position Management (V10.8+):

    MAX_CONCURRENT_POSITIONS = 3
    QUEUE_MAX_SIZE = 5
    QUEUE_EXPIRY_HOURS = 4
    QUEUE_PRICE_TOLERANCE = 0.01  # 1%

[12.4] Entry Scoring Weights (V10.8.1+):

    SCORE_WEIGHTS = {
        "technical": 35,    # RSI + BB
        "obi": 15,          # Order Book Imbalance (reduced)
        "volume": 25,       # Volume spike
        "momentum": 25      # Green candle
    }

[12.5] DCA Settings:

    DCA_LAYERS = {
        1: {"trigger": -0.03, "add_percent": 0.50},
        2: {"trigger": -0.06, "add_percent": 0.75},
        3: {"trigger": -0.10, "add_percent": 1.00}
    }

[12.6] Safety Settings:

    MAX_DRAWDOWN_PERCENT = 0.15
    API_TIMEOUT_SECONDS = 10
    KILL_SWITCH_TIMEOUT = 60
    BALANCE_MISMATCH_HALT = 0.05
    BALANCE_MISMATCH_WARN = 0.01


[12.7] Rate Limiting:

    REQUESTS_PER_MINUTE = 25
    MIN_REQUEST_SPACING = 2.5  # seconds

[12.8] Profit Router:

    BTC_HEALTH_THRESHOLDS = {
        "STRONG": {"rsi_min": 60, "above_ema": True, "macd_positive": True},
        "WEAK": {"rsi_max": 40, "below_ema": True, "macd_negative": True}
    }
    
    PROFIT_SPLIT = {
        "STRONG": {"btc": 0.80, "paxg": 0.20},
        "NEUTRAL": {"btc": 0.50, "paxg": 0.50},
        "WEAK": {"btc": 0.20, "paxg": 0.80}
    }

[12.9] Emergency Refuel:

    PAXG_MAX_SELL_PERCENT = 0.50
    REFUEL_COOLDOWN_HOURS = 24
    USDT_LOW_THRESHOLD = 0.20  # 20% of slot capital

[12.10] Telegram:

    TELEGRAM_BOT_TOKEN = "from .env"
    TELEGRAM_CHAT_ID = "from .env"
    TELEGRAM_PROXY_HOST = "127.0.0.1"
    TELEGRAM_PROXY_PORT = 1080
    HEARTBEAT_INTERVAL_MINUTES = 30  # [NEW V10.8]

[12.11] Nobitex:

    NOBITEX_API_KEY = "from .env"
    NOBITEX_BASE_URL = "https://api.nobitex.ir"
    TAKER_FEE = 0.0035
    MAKER_FEE = 0.0025

[12.12] Security Filters [NEW V10.8.2]:

    MAX_SPREAD_PERCENT = 0.005        # 0.5%
    WICK_BODY_RATIO_MAX = 3.0         # wick > 3x body = ignore
    VOLUME_SPIKE_MULTIPLIER = 10      # > 10x avg = suspicious
    MIN_ORDER_INTERVAL_SECONDS = 5    # anti-duplicate
    STATE_BACKUP_INTERVAL_MINUTES = 5
    STATE_BACKUP_KEEP_COUNT = 10

================================================================================
SECTION 13 â€” WATCHDOG MODULE (BELLE)
================================================================================

[13.1] Core Responsibilities:

    +-----+----------------------------------+----------------------------------+
    | #   | Task                             | Interval                         |
    +-----+----------------------------------+----------------------------------+
    | 1   | Health Check (API ping)          | Every 60 seconds                 |
    | 2   | Balance Verification             | Every 60 seconds                 |
    | 3   | Drawdown Calculation             | Every 60 seconds                 |
    | 4   | BTC Crash Detection              | Every 60 seconds                 |
    | 5   | State File Integrity             | Every 60 seconds [NEW V10.8.2]   |
    | 6   | Heartbeat Telegram               | Every 30 minutes [NEW V10.8]     |
    +-----+----------------------------------+----------------------------------+

[13.2] Health Check Flow:

    EVERY 60 SECONDS:
        1. Ping Nobitex API (GET /v2/options)
        2. IF timeout > 10s:
            - Increment failure_count
        3. IF failure_count >= 3:
            - Trigger HARDWARE KILL SWITCH
        4. IF success:
            - Reset failure_count to 0

[13.3] Heartbeat Message Format [NEW V10.8]:

    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    ğŸ«€ OCEAN HUNTER HEARTBEAT
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â° Time: 2025-12-30 14:30:00
    ğŸ“Š Mode: LIVE_FULL
    ğŸ’° Portfolio: $4,125.50 (+3.14%)
    ğŸ“ˆ Open Positions: 2/3
    ğŸ”„ Queue: 1 signal waiting
    âš¡ BTC Health: NEUTRAL
    ğŸ›¡ï¸ Security: ALL CLEAR
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[13.4] Alert Priority Levels:

    +----------+------------------+----------------------------------------+
    | Level    | Telegram Icon    | Use Case                               |
    +----------+------------------+----------------------------------------+
    | INFO     | â„¹ï¸               | Trade executed, profit taken           |
    | WARNING  | âš ï¸               | Spread high, volume spike              |
    | CRITICAL | ğŸš¨               | Drawdown breach, API failure           |
    | FATAL    | â˜ ï¸               | Kill switch activated                  |
    +----------+------------------+----------------------------------------+
================================================================================
SECTION 14 â€” EXECUTION FLOW (MAIN LOOP)
================================================================================

[14.1] Startup Sequence:

    1. Load .env (API keys)
    2. Load config.py (parameters)
    3. Load/Create state.json
    4. Validate state checksum [NEW V10.8.2]
    5. Verify API connectivity
    6. Sync balances with exchange
    7. Check trading mode (PAPER/LIVE_TEST/LIVE_FULL)
    8. Start Watchdog thread
    9. Send startup alert to Telegram
    10. Enter main loop

[14.2] Main Loop (Every 60 Seconds):

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         MAIN LOOP START                             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 1: Check System State                                          â”‚
    â”‚   - IF HALTED â†’ Skip to END                                         â”‚
    â”‚   - IF EXIT_ONLY â†’ Skip entry logic                                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 2: Fetch Market Data                                           â”‚
    â”‚   - Get OHLCV for all 5 altcoins (M15)                              â”‚
    â”‚   - Get BTC OHLCV (1H) for health check                             â”‚
    â”‚   - Get order books for OBI                                         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 3: Security Filters [NEW V10.8.2]                              â”‚
    â”‚   - Check spread for each symbol                                    â”‚
    â”‚   - Check wick anomaly on latest candle                             â”‚
    â”‚   - Check volume sanity                                             â”‚
    â”‚   - IF ANY FILTER TRIGGERED â†’ Flag symbol, reduce/block             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 4: Calculate Indicators                                        â”‚
    â”‚   - RSI(14), EMA(20), BB(20,2), MACD(12,26,9)                       â”‚
    â”‚   - OBI from order book                                             â”‚
    â”‚   - Volume SMA(20)                                                  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 5: Assess BTC Health                                           â”‚
    â”‚   - Determine STRONG / NEUTRAL / WEAK                               â”‚
    â”‚   - IF WEAK â†’ Block new entries [NEW V10.8.1]                       â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 6: Score Entry Candidates                                      â”‚
    â”‚   - For each altcoin without open position:                         â”‚
    â”‚     - Calculate entry score (Technical + OBI + Volume + Momentum)   â”‚
    â”‚     - Weights: 35 + 15 + 25 + 25 = 100 [V10.8.1]                    â”‚
    â”‚     - IF score >= 70 â†’ Add to candidates                            â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 7: Position Management [NEW V10.8]                             â”‚
    â”‚   - Count open positions                                            â”‚
    â”‚   - IF open_count < 3 â†’ Execute best candidate                      â”‚
    â”‚   - IF open_count >= 3 â†’ Add to WAITING_QUEUE                       â”‚
    â”‚   - Process queue (check expiry, price tolerance)                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 8: Execute Entry (If Approved)                                 â”‚
    â”‚   - Acquire ORDER_LOCK [NEW V10.8.2]                                â”‚
    â”‚   - Place LIMIT order with 0.1% offset [V10.8.1]                    â”‚
    â”‚   - Wait up to 30 seconds for fill                                  â”‚
    â”‚   - IF not filled â†’ Cancel and place MARKET order                   â”‚
    â”‚   - Release ORDER_LOCK                                              â”‚
    â”‚   - Update state.json                                               â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 9: Manage Open Positions                                       â”‚
    â”‚   - For each open position:                                         â”‚
    â”‚     - Check exit conditions (TP / Trailing)                         â”‚
    â”‚     - Check DCA triggers                                            â”‚
    â”‚     - Execute DCA if triggered (with PAXG refuel if needed)         â”‚
    â”‚     - Execute exit if profit target hit                             â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 10: Profit Distribution                                        â”‚
    â”‚   - IF position closed with profit:                                 â”‚
    â”‚     - Route profit based on BTC health state                        â”‚
    â”‚     - Execute BTC/PAXG purchases                                    â”‚
    â”‚     - Return principal to USDT pool                                 â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ STEP 11: State Persistence                                          â”‚
    â”‚   - Save state.json                                                 â”‚
    â”‚   - Backup if 5 minutes passed [NEW V10.8.2]                        â”‚
    â”‚   - Log trade to trades.xlsx                                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                                    â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                         MAIN LOOP END                               â”‚
    â”‚                    (Wait 60 seconds, repeat)                        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
SECTION 15 â€” TESTING PROTOCOL
================================================================================

[15.1] Unit Tests Required:

    +-----+---------------------------+--------------------------------------------+
    | #   | Module                    | Test Cases                                 |
    +-----+---------------------------+--------------------------------------------+
    | 1   | indicators.py             | RSI, EMA, BB, MACD, ATR accuracy           |
    | 2   | orderflow.py              | OBI correctness vs raw order book          |
    | 3   | btc_health.py             | STRONG / NEUTRAL / WEAK classification     |
    | 4   | strategy.py               | Entry score calculation (weighted)         |
    | 5   | dca_manager.py            | DCA triggers, WAIT MODE logic              |
    | 6   | profit_router.py          | Profit split consistency                   |
    | 7   | refuel.py                 | Emergency Refuel conditions                |
    | 8   | rate_limiter.py           | Token bucket + spacing enforcement         |
    | 9   | state_manager.py          | Save / load / checksum / restore           |
    | 10  | security_filters/*        | Spread, Wick, Volume sanity [V10.8.2]      |
    +-----+---------------------------+--------------------------------------------+

[15.2] Integration Tests:

    1. Full lifecycle trade:
        Entry â†’ DCA L1 â†’ DCA L2 â†’ Exit â†’ Profit Split
    2. Emergency Refuel path (PAXG in profit)
    3. WAIT MODE activation (PAXG in loss)
    4. Global Stop activation + recovery
    5. Queue behavior:
        - Add when full
        - Expiry (4h)
        - Price deviation > 2%
    6. API failure simulation
    7. State corruption & auto-restore [NEW V10.8.2]

[15.3] Paper Trading Requirements:

    - Minimum runtime: 72 continuous hours
    - Minimum simulated trades: 10
    - Must include:
        â€¢ One DCA scenario
        â€¢ One trailing exit
        â€¢ One profit routing to BTC
        â€¢ One profit routing to PAXG
    - Must trigger at least:
        â€¢ One security filter event
        â€¢ One heartbeat log
================================================================================
SECTION 16 â€” DEPLOYMENT CHECKLIST
================================================================================

[16.1] Pre-Deployment (MANDATORY):

    [ ] Nobitex API key with READ + TRADE only
    [ ] Withdrawal permission DISABLED
    [ ] IP Whitelist enabled (server IP only) [V10.8.2]
    [ ] .env permissions set to 600
    [ ] .gitignore blocks .env and state.json
    [ ] All unit tests PASSED
    [ ] Paper mode completed (â‰¥72h)
    [ ] Telegram bot tested (alerts + heartbeat)
    [ ] Server timezone = UTC
    [ ] Disk space > 20% free
    [ ] CPU/RAM stable under load

[16.2] Mode Progression (STRICT):

    PAPER
      â””â”€ after 72h + approval â†’
    LIVE_TEST (Max exposure: 50 USDT)
      â””â”€ after 7 days + positive PnL â†’
    LIVE_FULL

[16.3] Go-Live Sequence:

    1. Set MODE = "LIVE_TEST"
    2. Start system
    3. Confirm startup alert
    4. Monitor logs + Telegram closely
    5. Review trades.xlsx daily
    6. Promote to LIVE_FULL only after approval

[16.4] Rollback Plan:

    IF unexpected behavior:
        - Switch MODE to PAPER
        - Disable API key
        - Review logs + state backups
        - Restart only after root cause identified
================================================================================
SECTION 17 â€” FINAL LOCK & ARCHITECTURE STATUS
================================================================================

Architecture Name:
    OCEAN HUNTER â€” COMPLETE SECURE ARCHITECTURE

Version:
    V10.8.2

Trading Type:
    SPOT â€” NO LEVERAGE â€” NO STOP LOSS

Risk Philosophy:
    â€¢ Capital preservation > profit speed
    â€¢ BTC & PAXG = long-term vaults
    â€¢ USDT = operational fuel only

Security Philosophy:
    â€¢ Assume exchange misbehavior
    â€¢ Assume network failure
    â€¢ Assume software bugs
    â€¢ Protect capital above all

Status:
    âœ… ARCHITECTURE COMPLETE
    âœ… SECURITY HARDENED
    âœ… READY FOR IMPLEMENTATION
    âœ… FINAL â€” NO FURTHER CHANGES WITHOUT VERSION BUMP

================================================================================
ARCHITECTURE REFERENCE CODE:
REF-ARCH-V10.8.2-FINAL-LOCK-610
===================================================================================== SECTION 17 â€” TEST FRAMEWORK ARCHITECTURE [V10.8.2]
[17.1] FRAMEWORK OVERVIEW:

Scenarios (JSON) â”€â”€â”

Candles (CSV) â”€â”€â”€â”€â”€â”¼â”€â”€â–¶ TestSimulatorProvider â”€â”€â–¶ Engine â”€â”€â–¶ Reporter

OrderBooks (JSON) â”€â”¤

Wallets (JSON) â”€â”€â”€â”€â”˜

Config Switch: DATA_MODE = â€œLIVEâ€ | â€œTESTâ€

[17.2] DATA PROVIDER INTERFACE (IDataProvider):

Methods:

get_candles(symbol, timeframe, count) â†’ List[Candle]

get_orderbook(symbol) â†’ OrderBook

get_balance(asset) â†’ Balance

get_all_balances() â†’ Dict[str, Balance]

place_order(symbol, side, amount, order_type, price) â†’ OrderResult

cancel_order(order_id) â†’ bool

get_ticker(symbol) â†’ Ticker

Implementations:

NobitexLiveProvider (modules/network/nobitex.py)

Data Source: Nobitex REST API
Orders: Real execution
Used When: DATA_MODE = â€œLIVEâ€
TestSimulatorProvider (tests/providers/test_provider.py)

Data Source: CSV + JSON files
Orders: Virtual wallet update
Used When: DATA_MODE = â€œTESTâ€
[17.3] TEST CONFIGURATION (config.py):

DATA_MODE = â€œLIVEâ€

TEST_CONFIG = {

â€œscenario_fileâ€: â€œSC-001-basic-entry-exit.jsonâ€,

â€œcandle_speedâ€: â€œINSTANTâ€,

â€œenable_loggingâ€: True,

â€œoutput_formatâ€: [â€œJSONâ€, â€œEXCELâ€],

â€œtelegram_reportâ€: True

}

Candle Speed Options:

INSTANT = Process all candles immediately (batch test)

FAST = 1 second per candle (visual debugging)

REALTIME = 15 minutes per M15 candle (realistic simulation)

[17.4] DIRECTORY STRUCTURE:

tests/

â”œâ”€â”€ init.py

â”œâ”€â”€ conftest.py

â”œâ”€â”€ run_tests.py

â”œâ”€â”€ data/

â”‚ â”œâ”€â”€ candles/

â”‚ â”‚ â”œâ”€â”€ SOL_M15.csv, SOL_1H.csv

â”‚ â”‚ â”œâ”€â”€ BNB_M15.csv, BNB_1H.csv

â”‚ â”‚ â”œâ”€â”€ XRP_M15.csv, XRP_1H.csv

â”‚ â”‚ â”œâ”€â”€ AVAX_M15.csv, AVAX_1H.csv

â”‚ â”‚ â”œâ”€â”€ LINK_M15.csv, LINK_1H.csv

â”‚ â”‚ â”œâ”€â”€ BTC_1H.csv, PAXG_1H.csv

â”‚ â”œâ”€â”€ orderbooks/

â”‚ â”‚ â”œâ”€â”€ SOL.json, BNB.json, XRP.json, AVAX.json, LINK.json

â”‚ â”œâ”€â”€ scenarios/

â”‚ â”‚ â”œâ”€â”€ SC-001 to SC-015 (see 17.7)

â”‚ â””â”€â”€ wallets/

â”‚ â””â”€â”€ initial_wallet_v10.8.2.json

â”œâ”€â”€ providers/

â”‚ â”œâ”€â”€ init.py

â”‚ â”œâ”€â”€ test_provider.py

â”‚ â”œâ”€â”€ virtual_wallet.py

â”‚ â”œâ”€â”€ candle_player.py

â”‚ â””â”€â”€ order_simulator.py

â”œâ”€â”€ runners/

â”‚ â”œâ”€â”€ init.py

â”‚ â”œâ”€â”€ scenario_runner.py

â”‚ â”œâ”€â”€ batch_runner.py

â”‚ â””â”€â”€ interactive_runner.py

â”œâ”€â”€ reporters/

â”‚ â”œâ”€â”€ init.py

â”‚ â”œâ”€â”€ json_reporter.py

â”‚ â”œâ”€â”€ excel_reporter.py

â”‚ â””â”€â”€ telegram_reporter.py

â””â”€â”€ outputs/

â””â”€â”€ .gitkeep

[17.5] VIRTUAL WALLET SYSTEM:

Purpose: Track simulated balances during test scenarios

Initialization: Load from tests/data/wallets/initial_wallet_v10.8.2.json

State Structure:

{

â€œUSDTâ€: {â€œavailableâ€: 400, â€œlockedâ€: 0},

â€œSOLâ€: {â€œavailableâ€: 0, â€œlockedâ€: 0, â€œavg_priceâ€: 0},

â€œBNBâ€: {â€œavailableâ€: 0, â€œlockedâ€: 0, â€œavg_priceâ€: 0},

â€œXRPâ€: {â€œavailableâ€: 0, â€œlockedâ€: 0, â€œavg_priceâ€: 0},

â€œAVAXâ€: {â€œavailableâ€: 0, â€œlockedâ€: 0, â€œavg_priceâ€: 0},

â€œLINKâ€: {â€œavailableâ€: 0, â€œlockedâ€: 0, â€œavg_priceâ€: 0},

â€œBTCâ€: {â€œavailableâ€: 0.005, â€œlockedâ€: 0, â€œavg_priceâ€: 42000},

â€œPAXGâ€: {â€œavailableâ€: 0.08, â€œlockedâ€: 0, â€œavg_priceâ€: 2500}

}

Operations:

BUY(symbol, amount_usdt, price):

Check USDT available >= amount_usdt
Calculate quantity = amount_usdt / price
Apply fee (0.35%)
Deduct USDT
Add to symbol balance
Update avg_price (weighted average)
SELL(symbol, quantity, price):

Check symbol available >= quantity
Calculate received_usdt = quantity * price
Apply fee (0.35%)
Deduct from symbol
Add to USDT balance
[17.6] SCENARIO FILE FORMAT:

{

â€œscenario_idâ€: â€œSC-001â€,

â€œnameâ€: â€œBasic Entry and Exitâ€,

â€œdescriptionâ€: â€œTest entry at score 75, exit at 2% profitâ€,

â€œduration_candlesâ€: 100,

â€œinitial_walletâ€: â€œinitial_wallet_v10.8.2.jsonâ€,

â€œcandle_filesâ€: {â€œSOLâ€: â€œSOL_M15.csvâ€, â€œBTCâ€: â€œBTC_1H.csvâ€},

â€œorderbook_filesâ€: {â€œSOLâ€: â€œSOL.jsonâ€},

â€œexpected_resultsâ€: {

â€œtotal_tradesâ€: 1,

â€œwinning_tradesâ€: 1,

â€œfinal_usdt_minâ€: 400,

â€œbtc_vault_increasedâ€: true

},

â€œassertionsâ€: [

{â€œtypeâ€: â€œentry_triggeredâ€, â€œsymbolâ€: â€œSOLâ€, â€œcandle_indexâ€: 15},

{â€œtypeâ€: â€œexit_triggeredâ€, â€œsymbolâ€: â€œSOLâ€, â€œcandle_indexâ€: 45},

{â€œtypeâ€: â€œprofit_routedâ€, â€œdestinationâ€: â€œBTCâ€}

]

}

[17.7] TEST SCENARIOS (15 CORE):

SC-001: Basic Entry/Exit (score threshold + take profit)

SC-002: DCA Layer 1 (-3% trigger)

SC-003: DCA Layer 2 (-6% trigger)

SC-004: DCA Layer 3 (-10% trigger)

SC-005: Emergency Refuel (PAXG in profit)

SC-006: WAIT MODE (PAXG in loss)

SC-007: Trailing Exit (activate after +1%)

SC-008: BTC Strong (80/20 split)

SC-009: BTC Weak (20/80 split + entry block)

SC-010: Global Stop (BTC -8% in 4h)

SC-011: Spread Filter (>0.5% rejection)

SC-012: Wick Filter (wick > 3x body)

SC-013: Volume Sanity (>10x avg rejection)

SC-014: Queue Full (3 positions + queue)

SC-015: Max Positions (limit enforcement)

[17.8] CANDLE CSV FORMAT:

timestamp,open,high,low,close,volume,scenario_tag

1704067200,100.5,102.3,99.8,101.2,15000,ENTRY_SIGNAL

1704068100,101.2,103.5,100.9,102.8,18000,NORMAL

1704069000,102.8,103.0,98.5,99.2,25000,DCA_L1

Scenario Tags:

ENTRY_SIGNAL, DCA_L1, DCA_L2, DCA_L3, EXIT_PROFIT

EXIT_TRAILING, REFUEL_TRIGGER, WAIT_MODE, NORMAL

[17.9] ORDERBOOK JSON FORMAT:

{

â€œsymbolâ€: â€œSOLâ€,

â€œtimestampâ€: 1704067200,

â€œbidsâ€: [[100.5, 150], [100.4, 200], â€¦],

â€œasksâ€: [[100.6, 120], [100.7, 180], â€¦],

â€œspread_percentâ€: 0.001,

â€œobiâ€: 0.15

}

[17.10] TEST REPORTER OUTPUT:

JSON (tests/outputs/report_SC-001_YYYYMMDD_HHMM.json):

{

â€œscenario_idâ€: â€œSC-001â€,

â€œstatusâ€: â€œPASSâ€,

â€œduration_secondsâ€: 2.5,

â€œtrades_executedâ€: 1,

â€œassertions_passedâ€: 3,

â€œassertions_failedâ€: 0,

â€œfinal_walletâ€: {â€¦},

â€œtrade_logâ€: [â€¦]

}

Excel (tests/outputs/report_SC-001_YYYYMMDD_HHMM.xlsx):

Sheet 1: Summary (Pass/Fail, Duration, Stats)

Sheet 2: Trade Log (All executed trades)

Sheet 3: Wallet History (Balance changes over time)

Sheet 4: Assertion Results (Each assertion detail)

Telegram Summary:

âœ… Test Report: SC-001

Status: PASS | Trades: 1 | Win Rate: 100%

Assertions: 3/3 passed | Duration: 2.5s

[17.11] BATCH EXECUTION:

Command: python tests/run_tests.py --all

Process:

Load all scenarios from tests/data/scenarios/
Execute each scenario sequentially
Collect results
Generate combined report
Send summary to Telegram
Combined Report:

{

â€œtotal_scenariosâ€: 15,

â€œpassedâ€: 14,

â€œfailedâ€: 1,

â€œfailed_scenariosâ€: [â€œSC-012-wick-filterâ€],

â€œtotal_durationâ€: 45.2,

â€œtimestampâ€: â€œ2026-01-04T12:00:00Zâ€

}

[17.12] INTEGRATION WITH SECTION 15:

Unit Tests (Section 15.1):

Use TestSimulatorProvider for isolated module testing
Mock specific scenarios per module
Integration Tests (Section 15.2):

Run full scenarios (SC-001 to SC-015)
Validate complete trade lifecycle
Paper Trading (Section 15.3):

Extended scenario runs (72h equivalent data)
Must pass all 15 scenarios before LIVE_TEST
Progression Gate:

All 15 scenarios PASS â†’ Paper Mode OK â†’ LIVE_TEST eligible

================================================================================ END OF SECTION 17 â€” TEST FRAMEWORK


====================
File: Ai_Tools\build.py
====================
# AI_Tools/build.py â€” Phase 17: Paper Trading Simulation
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# Ref: PHASE-17-PAPER-TRADING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import os
import sys
import subprocess
import time

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 1. SETUP PATHS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
PROJECT_ROOT = os.path.dirname(SCRIPT_DIR)
sys.path.append(SCRIPT_DIR)

try:
    import context_gen
    import setup_git
except ImportError:
    pass

VENV_PYTHON = os.path.join(PROJECT_ROOT, ".venv", "Scripts", "python.exe")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 2. THE PAPER TRADING BOT (run_bot.py)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

BOT_CONTENT = r'''
import os
import time
import requests
import statistics
import math
from datetime import datetime
from dotenv import load_dotenv

# Load Environment
load_dotenv()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CONFIG â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SYMBOL = "BTCUSDT"
TIMEFRAME = "1m"
ENTRY_THRESHOLD = 70       # Enter if Score >= 70
TAKE_PROFIT_PCT = 1.5      # Sell if Profit >= 1.5%
STOP_LOSS_PCT = -2.0       # Sell if Loss >= 2.0% (Simulated Safety)

# API CONFIG
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
PROXY_URL = os.getenv("HTTPS_PROXY", "http://127.0.0.1:10809")
PROXIES = {"http": PROXY_URL, "https": PROXY_URL}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• PAPER WALLET â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
class PaperWallet:
    def __init__(self, initial_usdt=1000):
        self.usdt = initial_usdt
        self.btc = 0.0
        self.entry_price = 0.0
        self.in_position = False
        self.trades = 0

    def buy(self, price):
        if self.in_position: return False
        amount_to_buy = self.usdt  # All in for simulation
        self.btc = amount_to_buy / price
        self.usdt = 0
        self.entry_price = price
        self.in_position = True
        return True

    def sell(self, price, reason):
        if not self.in_position: return False
        sale_value = self.btc * price
        pnl = sale_value - (self.btc * self.entry_price)
        pnl_pct = (pnl / (self.btc * self.entry_price)) * 100
        
        self.usdt = sale_value
        self.btc = 0
        self.in_position = False
        self.trades += 1
        return pnl, pnl_pct

wallet = PaperWallet(initial_usdt=1000)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• TELEGRAM â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def send_telegram(msg):
    if not TG_TOKEN or not TG_CHAT_ID: return
    url = f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
    payload = {"chat_id": TG_CHAT_ID, "text": msg, "parse_mode": "HTML"}
    try:
        requests.post(url, json=payload, timeout=5)
    except:
        try:
            requests.post(url, json=payload, proxies=PROXIES, timeout=5)
        except: pass

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MARKET DATA â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def get_market_data():
    base_url = "https://api.mexc.com/api/v3/klines"
    params = {"symbol": SYMBOL, "interval": TIMEFRAME, "limit": 50}
    try:
        resp = requests.get(base_url, params=params, timeout=5)
        return resp.json()
    except:
        try:
            resp = requests.get(base_url, params=params, proxies=PROXIES, timeout=5)
            return resp.json()
        except: return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• INDICATORS â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def calculate_indicators(klines):
    if not klines: return None
    closes = [float(k[4]) for k in klines]
    opens = [float(k[1]) for k in klines]
    volumes = [float(k[5]) for k in klines]
    
    # RSI
    period = 14
    if len(closes) < period + 1: return None
    deltas = [closes[i] - closes[i-1] for i in range(1, len(closes))]
    gains = [d if d > 0 else 0 for d in deltas]
    losses = [abs(d) if d < 0 else 0 for d in deltas]
    avg_gain = sum(gains[-period:]) / period
    avg_loss = sum(losses[-period:]) / period
    rs = avg_gain / avg_loss if avg_loss != 0 else 0
    rsi = 100 - (100 / (1 + rs)) if avg_loss != 0 else 100

    # BB
    slice_data = closes[-20:]
    sma = sum(slice_data) / 20
    std = statistics.stdev(slice_data)
    bb_lower = sma - (2 * std)

    # Volume Spike
    curr_vol = volumes[-1]
    avg_vol = sum(volumes[-21:-1]) / 20
    vol_spike = curr_vol > (1.5 * avg_vol)

    return {
        "price": closes[-1],
        "rsi": rsi,
        "bb_lower": bb_lower,
        "vol_spike": vol_spike,
        "is_green": closes[-1] > opens[-1]
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SCORING â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def get_score(data):
    score = 0
    reasons = []
    if data['rsi'] < 40: score += 20; reasons.append("RSI Oversold")
    if data['price'] < data['bb_lower']: score += 15; reasons.append("Below BB")
    if data['vol_spike']: score += 25; reasons.append("Vol Spike")
    if data['is_green']: score += 25; reasons.append("Bullish Candle")
    return score, reasons

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• MAIN LOOP â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def main():
    os.system('cls' if os.name == 'nt' else 'clear')
    print("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—")
    print(f"â•‘ ğŸ“ PAPER TRADING SIMULATION (SAFE MODE)          â•‘")
    print(f"â•‘ ğŸ’° Wallet: ${wallet.usdt:.2f} USDT                      â•‘")
    print("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•")
    
    send_telegram("ğŸ“ <b>PAPER TRADING STARTED</b>\nSimulated Wallet: $1000")
    
    try:
        while True:
            klines = get_market_data()
            if klines:
                data = calculate_indicators(klines)
                score, reasons = get_score(data)
                price = data['price']
                
                # Console Output
                timestamp = datetime.now().strftime("%H:%M:%S")
                
                if wallet.in_position:
                    # CHECK FOR EXIT
                    curr_val = wallet.btc * price
                    pnl_pct = ((curr_val - 1000) / 1000) * 100 # Approx PnL based on initial
                    pnl_color = "\033[92m" if pnl_pct > 0 else "\033[91m"
                    
                    print(f"[{timestamp}] ğŸ’¼ HOLDING | Price: {price} | PnL: {pnl_color}{pnl_pct:.2f}%\033[0m")
                    
                    # Exit Conditions
                    exit_msg = ""
                    if pnl_pct >= TAKE_PROFIT_PCT:
                        pnl, pct = wallet.sell(price, "Take Profit")
                        exit_msg = f"âœ… <b>TAKE PROFIT</b> (+{pct:.2f}%)"
                    elif pnl_pct <= STOP_LOSS_PCT:
                        pnl, pct = wallet.sell(price, "Stop Loss")
                        exit_msg = f"ğŸ›‘ <b>STOP LOSS</b> ({pct:.2f}%)"
                    
                    if exit_msg:
                        print(f"\nğŸ’° {exit_msg} | New Balance: ${wallet.usdt:.2f}\n")
                        send_telegram(f"{exit_msg}\nPrice: {price}\nBalance: ${wallet.usdt:.2f}")

                else:
                    # CHECK FOR ENTRY
                    s_color = "\033[92m" if score >= ENTRY_THRESHOLD else "\033[90m"
                    print(f"[{timestamp}] ğŸ” {price} | Score: {s_color}{score}/100\033[0m | RSI: {data['rsi']:.1f}")
                    
                    if score >= ENTRY_THRESHOLD:
                        wallet.buy(price)
                        msg = (f"ğŸš€ <b>SIMULATED BUY</b>\n"
                               f"Price: {price}\n"
                               f"Score: {score}\n"
                               f"Reasons: {', '.join(reasons)}")
                        print(f"\nğŸ›’ BUY EXECUTED at {price}\n")
                        send_telegram(msg)
            else:
                print("âš ï¸  Network glitch...", end='\r')
                
            time.sleep(10)

    except KeyboardInterrupt:
        print("\nğŸ›‘ Bot Stopped.")

if __name__ == "__main__":
    main()
'''

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 3. BUILD PROCESS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main():
    print(f"\n[1/3] ğŸ“ Upgrading to Paper Trading Mode...")
    
    bot_path = os.path.join(PROJECT_ROOT, "run_bot.py")
    with open(bot_path, "w", encoding="utf-8") as f:
        f.write(BOT_CONTENT)
    
    print("      âœ… Simulation logic installed.")

    print("\n[2/3] ğŸ“š Git Sync...")
    if 'context_gen' in sys.modules:
        context_gen.create_context_file()
    if 'setup_git' in sys.modules:
        setup_git.sync("Phase 17: Paper Trading Integration")

    print("\n[3/3] ğŸ Launching Simulation...")
    time.sleep(2)
    if sys.platform == "win32":
        bat_path = os.path.join(PROJECT_ROOT, "run_dashboard.bat")
        os.system(f'start "" "{bat_path}"')
    else:
        subprocess.run([VENV_PYTHON, "run_dashboard.py"], cwd=PROJECT_ROOT)

if __name__ == "__main__":
    main()


====================
File: Ai_Tools\context_gen.py
====================

import os
import datetime

# CONFIG
OUTPUT_FILE = "LATEST_PROJECT_CONTEXT.txt"
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(SCRIPT_DIR)

# Folders to scan
INCLUDE_DIRS = ['AI_Tools', 'modules', 'tests'] 
EXCLUDE_DIRS = ['.git', '.venv', '__pycache__', 'context_backups', 'data', 'logs', 'candles', 'wallets', 'orderbooks']
# Note: We exclude raw data folders inside 'tests' from context to keep context small, 
# but include 'tests/core', 'tests/runners' etc.

EXTENSIONS = ['.py', '.txt', '.md', '.json', '.env']

def get_tree(startpath):
    tree = ""
    for root, dirs, files in os.walk(startpath):
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        level = root.replace(startpath, '').count(os.sep)
        indent = ' ' * 4 * (level)
        tree += f"{indent}{os.path.basename(root)}/\n"
        subindent = ' ' * 4 * (level + 1)
        for f in files:
            if any(f.endswith(ext) for ext in EXTENSIONS):
                tree += f"{subindent}{f}\n"
    return tree

def read_files(startpath):
    content = ""
    for root, dirs, files in os.walk(startpath):
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        for f in files:
            # Skip large data files even if json/txt
            if "LATEST_PROJECT_CONTEXT" in f: continue
            
            if any(f.endswith(ext) for ext in EXTENSIONS):
                path = os.path.join(root, f)
                rel_path = os.path.relpath(path, startpath)
                
                try:
                    with open(path, 'r', encoding='utf-8') as file:
                        content += f"\n{'='*20}\nFile: {rel_path}\n{'='*20}\n"
                        content += file.read() + "\n"
                except Exception as e:
                    content += f"\nError reading {rel_path}: {e}\n"
    return content

def create_context_file():
    timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    header = f"GENERATED: {timestamp}\n"
    header += f"VERSION: 3.1 (Phase 1: Virtual Wallet)\n\n"
    
    structure = "PROJECT STRUCTURE:\n" + get_tree(ROOT_DIR)
    file_contents = "\nFILE CONTENTS:\n" + read_files(ROOT_DIR)
    
    full_content = header + structure + file_contents
    
    output_path = os.path.join(SCRIPT_DIR, OUTPUT_FILE)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(full_content)
    
    print(f"âœ… Context generated at: {output_path}")

if __name__ == "__main__":
    create_context_file()


====================
File: Ai_Tools\mexc.txt
====================
mx0vglgT1sDiSHvzkz


5a9e39d83a7043d19dcbf41d7880eb1a

====================
File: Ai_Tools\nobitex.txt
====================
21f749091224d47ad759da36b6883b80942d55c2

====================
File: Ai_Tools\setup_git.py
====================
#!/usr/bin/env python3
"""
SETUP_GIT.PY V3.0 â€” GIT MANAGER WITH AUTO-LOGIN
Functions: setup() = one-time init | sync() = every build
Auth: Git Credential Manager (Browser OAuth)
"""
import os
import subprocess
import sys
import platform
from datetime import datetime

# === CONFIGURATION ===
GIT_USERNAME = "learner1495"
GIT_EMAIL = "mostafa53548188@gmail.com"
BRANCH = "main"

# === PATH SETUP ===
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT_DIR = os.path.dirname(SCRIPT_DIR)
REPO_NAME = os.path.basename(ROOT_DIR)
REMOTE_URL = f"https://github.com/{GIT_USERNAME}/{REPO_NAME}.git"


def run(cmd, cwd=None):
    """Run command and return (success, output)"""
    try:
        result = subprocess.run(
            cmd if isinstance(cmd, list) else cmd.split(),
            cwd=cwd or ROOT_DIR,
            capture_output=True,
            text=True,
            timeout=120
        )
        output = result.stdout.strip() or result.stderr.strip()
        return result.returncode == 0, output
    except Exception as e:
        return False, str(e)


def print_status(msg, success=True):
    """Print formatted status"""
    symbol = "âœ…" if success else "âŒ"
    print(f"      {symbol} {msg}")


def configure_credential_manager():
    """Setup Git Credential Manager for browser-based auth"""
    print("\n   ğŸ” Configuring Git Credential Manager...")
    
    system = platform.system()
    
    if system == "Windows":
        run(["git", "config", "--global", "credential.helper", "manager"])
        print_status("Windows Credential Manager configured")
    elif system == "Darwin":
        run(["git", "config", "--global", "credential.helper", "osxkeychain"])
        print_status("macOS Keychain configured")
    else:
        success, _ = run(["git", "credential-manager", "--version"])
        if success:
            run(["git", "config", "--global", "credential.helper", "manager-core"])
            print_status("Git Credential Manager Core configured")
        else:
            run(["git", "config", "--global", "credential.helper", "store"])
            print_status("Git credential store configured (fallback)", False)
    
    return True


def setup():
    """One-time Git initialization"""
    print("\n" + "=" * 60)
    print("   ğŸš€ SETUP_GIT.PY V3.0 â€” INITIAL SETUP")
    print("=" * 60)
    
    git_dir = os.path.join(ROOT_DIR, ".git")
    
    # Step 1: Configure credential manager
    configure_credential_manager()
    
    # Step 2: Set identity
    print("\n   ğŸ‘¤ Setting Git identity...")
    run(["git", "config", "--global", "user.name", GIT_USERNAME])
    run(["git", "config", "--global", "user.email", GIT_EMAIL])
    print_status(f"Identity: {GIT_USERNAME} <{GIT_EMAIL}>")
    
    # Step 3: Init repo if needed
    if not os.path.exists(git_dir):
        print("\n   ğŸ“ Initializing Git repository...")
        run(["git", "init"], cwd=ROOT_DIR)
        run(["git", "branch", "-M", BRANCH], cwd=ROOT_DIR)
        print_status(f"Repository initialized with branch: {BRANCH}")
    else:
        print_status("Repository already exists")
    
    # Step 4: Setup remote
    print("\n   ğŸŒ Configuring remote...")
    success, remotes = run(["git", "remote", "-v"], cwd=ROOT_DIR)
    if "origin" in remotes:
        run(["git", "remote", "set-url", "origin", REMOTE_URL], cwd=ROOT_DIR)
        print_status(f"Remote updated: {REMOTE_URL}")
    else:
        run(["git", "remote", "add", "origin", REMOTE_URL], cwd=ROOT_DIR)
        print_status(f"Remote added: {REMOTE_URL}")
    
    # Step 5: Create .gitignore
    gitignore_path = os.path.join(ROOT_DIR, ".gitignore")
    if not os.path.exists(gitignore_path):
        print("\n   ğŸ“„ Creating .gitignore...")
        gitignore_content = """.venv/
__pycache__/
*.pyc
*.pyo
.env
*.log
.DS_Store
Thumbs.db
*.db
context_backups/
"""
        with open(gitignore_path, "w", encoding="utf-8") as f:
            f.write(gitignore_content)
        print_status(".gitignore created")
    
    print("\n" + "=" * 60)
    print("   âœ… SETUP COMPLETE")
    print("=" * 60)
    return True


def sync(message=None):
    """Sync changes to GitHub"""
    print("\n" + "=" * 60)
    print("   ğŸ”„ SETUP_GIT.PY V3.0 â€” SYNC")
    print("=" * 60)
    
    # Auto-generate commit message if not provided
    if not message:
        message = f"Auto-sync: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    
    # Step 1: Check if .git exists
    git_dir = os.path.join(ROOT_DIR, ".git")
    if not os.path.exists(git_dir):
        print("   âš ï¸ Git not initialized. Running setup() first...")
        setup()
    
    # Step 2: Add all changes
    print("\n   ğŸ“¦ Staging changes...")
    success, output = run(["git", "add", "."], cwd=ROOT_DIR)
    print_status("Changes staged" if success else f"Stage failed: {output}", success)
    
    # Step 3: Check if there are changes to commit
    success, status = run(["git", "status", "--porcelain"], cwd=ROOT_DIR)
    if not status.strip():
        print_status("No changes to commit")
        print("\n" + "=" * 60)
        print("   âœ… SYNC COMPLETE â€” No changes")
        print("=" * 60)
        return True
    
    # Step 4: Commit
    print("\n   ğŸ’¾ Committing...")
    success, output = run(["git", "commit", "-m", message], cwd=ROOT_DIR)
    if success:
        print_status(f"Committed: {message[:50]}...")
    else:
        if "nothing to commit" in output:
            print_status("Nothing to commit")
        else:
            print_status(f"Commit issue: {output[:100]}", False)
    
    # Step 5: Push
    print("\n   ğŸš€ Pushing to GitHub...")
    print("      (Ø§Ú¯Ø± Ù…Ø±ÙˆØ±Ú¯Ø± Ø¨Ø§Ø² Ø´Ø¯ØŒ Ù„Ø§Ú¯ÛŒÙ† Ú©Ù†ÛŒØ¯)")
    
    success, output = run(["git", "push", "-u", "origin", BRANCH], cwd=ROOT_DIR)
    
    if success:
        print_status("Push successful!")
        print("\n" + "=" * 60)
        print("   âœ… SYNC COMPLETE")
        print(f"      Repo: https://github.com/{GIT_USERNAME}/{REPO_NAME}")
        print("=" * 60)
        return True
    else:
        if "rejected" in output:
            print_status("Push rejected â€” trying pull first...", False)
            run(["git", "pull", "--rebase", "origin", BRANCH], cwd=ROOT_DIR)
            success, output = run(["git", "push", "-u", "origin", BRANCH], cwd=ROOT_DIR)
            if success:
                print_status("Push after pull: Success")
                return True
            else:
                print_status("Push after pull: Failed", False)
                return False
        elif "Authentication" in output or "403" in output or "fatal" in output.lower():
            print_status("Authentication needed", False)
            print("\n" + "-" * 60)
            print("   ğŸ” AUTHENTICATION REQUIRED")
            print("-" * 60)
            print("\n   Ù…Ø±ÙˆØ±Ú¯Ø± Ø¨Ø§ÛŒØ¯ Ø¨Ø§Ø² Ø´ÙˆØ¯ Ø¨Ø±Ø§ÛŒ Ù„Ø§Ú¯ÛŒÙ† GitHub.")
            print("   Ø§Ú¯Ø± Ø¨Ø§Ø² Ù†Ø´Ø¯:")
            print("   1. https://github.com/settings/tokens")
            print("   2. Personal Access Token Ø¨Ø³Ø§Ø²ÛŒØ¯")
            print(f"   3. git push -u origin {BRANCH}")
            print("-" * 60)
            return False
        else:
            print_status(f"Push failed: {output[:100]}", False)
            return False


# === MAIN ===
if __name__ == "__main__":
    print("\n" + "=" * 60)
    print("ğŸ™ SETUP_GIT V3.0 â€” Standalone Mode")
    print("=" * 60)
    
    if len(sys.argv) > 1:
        if sys.argv[1] == "setup":
            setup()
        elif sys.argv[1] == "sync":
            msg = sys.argv[2] if len(sys.argv) > 2 else None
            sync(msg)
        else:
            print("Usage: python setup_git.py [setup|sync] [message]")
    else:
        if not os.path.exists(os.path.join(ROOT_DIR, ".git")):
            setup()
        sync("Manual sync from standalone")
    
    print("\nâœ… Done!")


====================
File: Ai_Tools\telegrambot.txt
====================
8519168043:AAEeRDhMogTxpElxgB0zUom9YzKXAnRBKew
user:oceanhunter_alert_bot
name:Ocean Hunter Alert

====================
File: Ai_Tools\WORKFLOW.txt
====================
################################################################################
#                    ğŸ”’ CRITICAL WORKFLOW & AUTOMATION RULES                   #
#                              VERSION 3.1 - FINAL#
#                           44 RULES | 9 PARTS + PART 0                        #
################################################################################

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 0: SYSTEM OVERVIEW (Ù†Ù…Ø§ÛŒ Ú©Ù„ÛŒ Ø³ÛŒØ³ØªÙ… â€” Ø§Ø¯ØºØ§Ù… Ø§Ø² AUTOMATION_GUIDE)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

[0.1] PURPOSE:
    Ø§ÛŒÙ† Ø³ÛŒØ³ØªÙ… Ø¨Ù‡ AI Ø§Ø¬Ø§Ø²Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯ Ø¨Ø¯ÙˆÙ† Ø¯Ø®Ø§Ù„Øª Ø¯Ø³ØªÛŒ Ú©Ø§Ø±Ø¨Ø±:
    âœ… Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ø³Ø§Ø²Ø¯ | âœ… venv Ø§ÛŒØ¬Ø§Ø¯ Ú©Ù†Ø¯ | âœ… pip install Ú©Ù†Ø¯
    âœ… ÙØ§ÛŒÙ„/ÙÙˆÙ„Ø¯Ø± Ø¨Ø³Ø§Ø²Ø¯ | âœ… Git sync Ú©Ù†Ø¯ | âœ… Ø¨Ø±Ù†Ø§Ù…Ù‡ Ø§Ø¬Ø±Ø§ Ú©Ù†Ø¯

[0.2] CORE PRINCIPLE:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  AI Ù‡Ø±Ú¯Ø² Ø§Ø² Ú©Ø§Ø±Ø¨Ø± Ù†Ø®ÙˆØ§Ù‡Ø¯ Ø¯Ø³ØªÛŒ ÙØ§ÛŒÙ„ Ø¨Ø³Ø§Ø²Ø¯ ÛŒØ§ Ú©Ø¯ Ú©Ù¾ÛŒ Ú©Ù†Ø¯.                 â”‚
    â”‚  ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÛŒØ§Øª Ø§Ø² Ø·Ø±ÛŒÙ‚ build.py Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯.                              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[0.3] BUILD.PY EXECUTION ORDER (ØªØ±ØªÛŒØ¨ Ù‚ÙÙ„â€ŒØ´Ø¯Ù‡ â€” ØºÛŒØ±Ù‚Ø§Ø¨Ù„ ØªØºÛŒÛŒØ±):â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  STEP 1: System Checks      â†’ Internet, DNS, Python version             â”‚
    â”‚  STEP 2: venv Setup         â†’ Create .venv if not exists                â”‚
    â”‚  STEP 3: pip Install        â†’ Install from requirements.txt            â”‚
    â”‚  STEP 4: Folder Creation    â†’ Create project directories               â”‚
    â”‚  STEP 5: File Creation      â†’ Create/modify project files              â”‚
    â”‚  STEP 6: Context Generation â†’ Run context_gen.create_context_file()    â”‚
    â”‚  STEP 7: Git Init           â†’ Run setup_git.setup() (ONLY if no .git)  â”‚
    â”‚  STEP 8: Git Syncâ†’ Run setup_git.sync() (ALWAYS)            â”‚
    â”‚  STEP 9: App Launch         â†’ Run main.py via venv Python              â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[0.4] FILE RESPONSIBILITIES:

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ WORKFLOW.txt       â”‚ Ù‚ÙˆØ§Ù†ÛŒÙ† Ø±ÙØªØ§Ø± AI + ØªÙ†Ø¸ÛŒÙ…Ø§Øª Ø«Ø§Ø¨Øª (Ø§ÛŒÙ† ÙØ§ÛŒÙ„)â”‚
    â”‚ ARCHITECTURE.txt   â”‚ Ù…Ø¹Ù…Ø§Ø±ÛŒ Ùˆ Ø§Ø³ØªØ±Ø§ØªÚ˜ÛŒ Ø®Ø§Øµ Ù¾Ø±ÙˆÚ˜Ù‡                       â”‚
    â”‚ context_gen.py     â”‚ ØªÙˆÙ„ÛŒØ¯ LATEST_PROJECT_CONTEXT.txt                  â”‚
    â”‚ setup_git.py       â”‚ Git manager: setup() ÛŒÚ©Ø¨Ø§Ø± | sync() Ù‡Ø± Ø¨ÛŒÙ„Ø¯       â”‚
    â”‚ build.py           â”‚ Ø§Ø¬Ø±Ø§ÛŒ ØªÙ…Ø§Ù… Ø¹Ù…Ù„ÛŒØ§Øª (Template â€” AI Ù¾Ø± Ù…ÛŒâ€ŒÚ©Ù†Ø¯)        â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

[0.5] CONTEXT & BACKUP LOCATION:
    âœ… LATEST_PROJECT_CONTEXT.txt â†’ Ø¯Ø§Ø®Ù„ AI_Tools/
    âœ… context_backups/           â†’ Ø¯Ø§Ø®Ù„ AI_Tools/âŒ Root Ù¾Ø±ÙˆÚ˜Ù‡ Ø¨Ø§ÛŒØ¯ ØªÙ…ÛŒØ² Ø¨Ù…Ø§Ù†Ø¯

[0.6] GIT CONFIGURATION (Ø«Ø§Ø¨Øª Ø¨Ø±Ø§ÛŒ ØªÙ…Ø§Ù… Ù¾Ø±ÙˆÚ˜Ù‡â€ŒÙ‡Ø§):

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  USERNAME:    learner1495                                               â”‚
    â”‚  EMAIL:       mostafa53548188@gmail.com                                 â”‚
    â”‚  REPO NAME:   = Ù†Ø§Ù… Ù¾ÙˆØ´Ù‡ Root Ù¾Ø±ÙˆÚ˜Ù‡ (Ø§ØªÙˆÙ…Ø§ØªÛŒÚ©)                          â”‚
    â”‚  REMOTE URL:  https://github.com/{USERNAME}/{REPO_NAME}.gitâ”‚
    â”‚  BRANCH:      main                                                      â”‚
    â”‚  AUTH METHOD: Git Credential Manager (Browser OAuth)                   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 1: AUTOMATION & BUILD RULES (Ù‚ÙˆØ§Ù†ÛŒÙ† 1-6)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. AUTOMATION STRATEGY:
   All modifications via build.py. No manual file edits by user.
   build.py handles: files, folders, pip, configs.

2. DIRECTORY STRUCTURE:
   Scripts in: ProjectRoot/AI_Tools/
   Project Root = parent of AI_Tools
   Use os.path.dirname(os.path.abspath(__file__)) for paths.

3. MANDATORY CONTEXT UPDATE:
   build.py MUST import and run context_gen.create_context_file() BEFORE Git.

4. GIT AUTOMATION:
   After context update, build.py calls setup_git.sync()
   sync() handles: git add . â†’ git commit â†’ git push
   âš ï¸ build.py Ù†Ø¨Ø§ÛŒØ¯ Ù…Ø³ØªÙ‚ÛŒÙ… git command Ø§Ø¬Ø±Ø§ Ú©Ù†Ø¯ â€” ÙÙ‚Ø· Ø§Ø² setup_git Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ø¯

5. EXECUTION:
   After Git, launch main app via venv Python.

6. COMPLEXITY MANAGEMENT:
   If >3 files or >400 lines: split into phases.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 2: ANTI-HALLUCINATION RULES (Ù‚ÙˆØ§Ù†ÛŒÙ† 7-11)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

7. BEFORE ANY CODE:
   a) State understanding
   b) List files to create/modify
   c) Describe changes
   d) Ask "Proceed?" if complex

8. WHEN UNCERTAIN:
   Say "I'm not sure about X. Clarify..."
   Never guess. Never invent requirements.

9. STRICT SCOPE:
   âŒ No unrequested features
   âŒ No architecture changes without asking
   âŒ No modifying unmentioned files
   âœ… Only do what was asked

10. FILE REFERENCES:
    Only reference files in context.
    If missing: ask before creating.

11. CODE OUTPUT:
    Show only changed parts (unless full requested).
    Use markers: # === CHANGED START ===
    Specify file path. Use syntax highlighting.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 3: RESPONSE STRUCTURE (Ù‚ÙˆØ§Ù†ÛŒÙ† 12-14)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

12. EVERY RESPONSE INCLUDES:
    1. Summary of work done
    2. Files modified/created
    3. Warnings/notes
    4. Next step statement
    5. Reference code (e.g., FIX-042)

13. MULTI-PART CODE:
    Use: # â•â•â• PART 1 OF 3: [Desc] â•â•â•
    Summarize at end.

14. ERROR IN RESPONSE:
    State problem â†’ Explain why â†’ Suggest fix â†’ Ask permission

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 4: CONTEXT AWARENESS (Ù‚ÙˆØ§Ù†ÛŒÙ† 15-17)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

15. CONTEXT PRIORITY:
    1. WORKFLOW rules (first)
    2. Project structure
    3. Existing code
    4. User request

16. FRESHNESS CHECK:
    Note "GENERATED ON" timestamp.
    If >24h old, suggest refresh.

17. MISSING INFO:
    Don't proceed blind. Ask for file or suggest context_gen.py run.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 5: PROJECT-SPECIFIC (Ù‚ÙˆØ§Ù†ÛŒÙ† 18-20)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

18. PROJECT TYPE: [User fills per project]

19. TECHNOLOGIES: Python 3.10+, SQLite, [frameworks per project]

20. CRITICAL FILES (NO DELETE):
    AI_Tools/build.py
    AI_Tools/context_gen.py
    AI_Tools/WORKFLOW.txt
    AI_Tools/setup_git.py
    AI_Tools/ARCHITECTURE.txt

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 6: COMMUNICATION (Ù‚ÙˆØ§Ù†ÛŒÙ† 21-23)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

21. LANGUAGE: Match user. Code/vars in English.

22. REFERENCE CODES: End with [TOPIC]-[NUM] (e.g., BUILD-001)

23. PROGRESS: Show step X of Y for multi-step tasks.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 7: ERROR HANDLING & SYSTEM CHECKS (Ù‚ÙˆØ§Ù†ÛŒÙ† 24-33)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

24. TRY-EXCEPT WRAPPING:
    All operations in build.py wrapped in try-except.
    Never bare except: â€” catch specific exceptions.
    Log errors with log_error("SECTION", str(e))

25. PRE-FLIGHT CHECKS (before network ops):
    25.1 Internet: ping/socket test
    25.2 DNS: resolve github.com
    25.3 Git Remote: git ls-remote --exit-code origin
    25.4 Python/Pip: version checks

26. INTERNET CHECK FUNCTION:
    Use socket with timeout=5.
    Return True/False. Log result.

27. NETWORK LIMITATION DETECTION:
    DNS Failure â†’ Log + Skip network opsFiltering â†’ Log + Warn
    Timeout â†’ Retry once + Log
    Auth Error â†’ Log + Show fix

28. GIT IDENTITY AUTO-CONFIG:
    Before commit, check user.name exists.
    If not: use values from PART 0 Section [0.6]

29. LOGGING STANDARD:
    Format: [TIMESTAMP] [LEVEL] [SECTION] Message
    Levels: INFO, WARN, ERROR, FATAL

30. GRACEFUL EXIT:
    Never crash abruptly.
    Structure: try â†’ except â†’ finally â†’ print_summary â†’ sys.exit(code)
    Codes: 0=Success, 1=Critical, 2=Unexpected, 3=Network fail

31. SUBPROCESS STANDARD:
    All external commands via run_subprocess(cmd, desc, critical=False)
    Includes: timeout, logging, error handling, return (bool, output)

32. BUILD SUMMARY REPORT:
    Print at end: System Checks status, Operations status, Errors, Warnings, Exit Code.

33. GIT AUTHENTICATION STANDARD:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  METHOD: Git Credential Manager (GCM) â€” Browser-based OAuthâ”‚
    â”‚  TRIGGER: First push OR when credentials expire                        â”‚
    â”‚  BEHAVIOR: Opens browser â†’ User logs in â†’ Token cached automatically   â”‚
    â”‚  FALLBACK: If no browser, show manual token instructionsâ”‚
    â”‚  CONFIG: credential.helper=manager (Windows) | manager-core (Linux)    â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    âš ï¸ Ù‡Ø±Ú¯Ø² Ø§Ø² Personal Access Token Ø¯Ø± Ú©Ø¯ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù†Ø´ÙˆØ¯
    âš ï¸ Ù‡Ø±Ú¯Ø² password Ø¯Ø± plaintext Ø°Ø®ÛŒØ±Ù‡ Ù†Ø´ÙˆØ¯

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 8: DOCUMENTATION REFERENCE RULES (Ù‚ÙˆØ§Ù†ÛŒÙ† 34-38)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

34. MANDATORY DOC CHECK:
    Before implementing any feature, AI MUST check if official docs exist.
    Never code from memory alone for libraries/APIs.

35. UNKNOWN LIBRARY HANDLING:
    If unfamiliar with a library:
    âŒ Do NOT guess syntax
    âœ… Ask user for docs link OR
    âœ… State: "I need to verify X library docs before proceeding"

36. API IMPLEMENTATION:
    For any external API (exchange, service, etc.):
    - Request official API docs
    - Verify endpoints, parameters, auth method
    - Never assume API structure

37. VERSION SENSITIVITY:
    Libraries change between versions.
    If version not specified: ask or state assumption clearly.

38. DOCUMENTATION PRIORITY:
    1. Official docs (highest)
    2. Context code examples
    3. User description
    4. AI knowledge (lowest â€” verify first)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 9: CODE COMPACTNESS RULES (Ù‚ÙˆØ§Ù†ÛŒÙ† 39-41)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

39. NAMING CONVENTION:
    âœ… Concise but readable names (e.g., get_bal not get_user_balance_from_api)
    âœ… Single-letter only for loops (i, j, k)
    âœ… Descriptive for functions/classes

40. CODE DENSITY:
    âœ… Combine related operations on single line where readable
    âœ… Use list/dict comprehensions where appropriate
    âœ… Minimal vertical whitespace (no triple blank lines)
    âœ… Remove excess comments (no "# this adds two numbers")âŒ No decorative ASCII art in production code
    âŒ No empty placeholder sections
    âŒ No repeated code â€” extract to functions

41. LINE EFFICIENCY:
    âœ… One-liner if simple: if x: do_y()
    âœ… Ternary where clear: result = a if cond else b
    âŒ No multi-line when one works
    âŒ No verbose logging for obvious operations
    Target: Maximum clarity with minimum lines.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
PART 10: FINAL AUTHORITY (Ù‚ÙˆØ§Ù†ÛŒÙ† 42-44)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

42. WORKFLOW SUPREMACY:
    This file (WORKFLOW.txt) is the FINAL AUTHORITY for AI behavior.
    If conflict with other files: WORKFLOW wins.

43. ARCHITECTURE RESPECT:
    ARCHITECTURE.txt defines project-specific logic.
    AI must follow it but cannot modify without explicit permission.

44. SINGLE RESPONSIBILITY:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ build.py           â”‚ Only executor â€” runs all operations             â”‚
    â”‚ context_gen.py     â”‚ Only context writer â€” generates context file    â”‚
    â”‚ setup_git.py       â”‚ Git manager â€” setup() once + sync() every build â”‚
    â”‚ WORKFLOW.txt       â”‚ Only behavior authority â€” AI rulesâ”‚
    â”‚ ARCHITECTURE.txt   â”‚ Only architecture authority â€” project logic     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    âš ï¸ Ù‡ÛŒÚ† ÙØ§ÛŒÙ„ÛŒ Ù†Ø¨Ø§ÛŒØ¯ ÙˆØ¸ÛŒÙÙ‡ ÙØ§ÛŒÙ„ Ø¯ÛŒÚ¯Ø± Ø±Ø§ Ø§Ù†Ø¬Ø§Ù… Ø¯Ù‡Ø¯

################################################################################
#END OF WORKFLOW.txt                               #
#VERSION 3.1 | 44 RULES | 10 PARTS                       #
###############################################################################

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
==========================
# AI_Tools/build.py â€” Template V3.4
# âš ï¸ Ø§ÛŒÙ† Template Ø§Ø³Øª â€” AI Ø¨Ø§ÛŒØ¯ ÙÙ‚Ø· Ø¨Ø®Ø´ CUSTOMIZE Ø±Ùˆ Ù¾Ø± Ú©Ù†Ù‡
# âš ï¸ Ø³Ø§Ø®ØªØ§Ø± Ú©Ù„ÛŒ Ù†Ø¨Ø§ÛŒØ¯ ØªØºÛŒÛŒØ± Ú©Ù†Ù‡
========================== â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# 9 Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø§ Error Handling Ú©Ø§Ù…Ù„ â€” Ø¨Ø¯ÙˆÙ† Ú©Ø±Ø´
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import os
import sys
import subprocess
import socket
from datetime import datetime

# â•â•â• Import Ù…Ø§Ú˜ÙˆÙ„â€ŒÙ‡Ø§ÛŒ Ø¯Ø§Ø®Ù„ÛŒ â•â•â•
import context_gen
import setup_git

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PATHS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
ROOT = os.path.dirname(SCRIPT_DIR)
VENV_PATH = os.path.join(ROOT, ".venv")
VENV_PYTHON = os.path.join(VENV_PATH, "Scripts", "python.exe") if sys.platform == "win32" else os.path.join(VENV_PATH, "bin", "python")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# â­ CUSTOMIZE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FOLDERS = []
NEW_FILES = {}
MODIFY_FILES = {}
MAIN_FILE = "main.py"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ERROR TRACKING
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
errors = []

def log_error(step, error):
    """Ø«Ø¨Øª Ø®Ø·Ø§ Ø¨Ø¯ÙˆÙ† ØªÙˆÙ‚Ù"""
    errors.append(f"[{step}] {error}")
    print(f"      âš ï¸ Error: {error}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# STEPS 1-6
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def step1_system():
    print("\n[1/9] ğŸŒ System Check...")
    try:
        socket.create_connection(("8.8.8.8", 53), timeout=3)
        print("      âœ… Internet OK")
    except Exception as e:
        log_error("Step1", f"No internet - {e}")

def step2_venv():
    print("\n[2/9] ğŸ Virtual Environment...")
    try:
        if os.path.exists(VENV_PYTHON):
            print("      âœ… Exists")
            return
        subprocess.run([sys.executable, "-m", "venv", VENV_PATH], check=True)
        print("      âœ… Created")
    except Exception as e:
        log_error("Step2", e)

def step3_deps():
    print("\n[3/9] ğŸ“¦ Dependencies...")
    try:
        req = os.path.join(ROOT, "requirements.txt")
        if not os.path.exists(req):
            print("      â„¹ï¸ No requirements.txt")
            return
        subprocess.run([VENV_PYTHON, "-m", "pip", "install", "-r", req], 
                      capture_output=True, check=True)
        print("      âœ… Installed")
    except Exception as e:
        log_error("Step3", e)

def step4_folders():
    print("\n[4/9] ğŸ“ Folders...")
    try:
        if not FOLDERS:
            print("      â„¹ï¸ None defined")
            return
        for f in FOLDERS:
            path = os.path.join(ROOT, f)
            if not os.path.exists(path):
                os.makedirs(path)
                print(f"      âœ… Created: {f}/")
    except Exception as e:
        log_error("Step4", e)

def step5_new_files():
    print("\n[5/9] ğŸ“ New Files...")
    try:
        if not NEW_FILES:
            print("      â„¹ï¸ None defined")
            return
        for path, content in NEW_FILES.items():
            full = os.path.join(ROOT, path)
            parent = os.path.dirname(full)
            if parent and not os.path.exists(parent):
                os.makedirs(parent)
            with open(full, "w", encoding="utf-8") as f:
                f.write(content)
            print(f"      âœ… Created: {path}")
    except Exception as e:
        log_error("Step5", e)

def step6_modify():
    print("\n[6/9] âœï¸ Modify Files...")
    try:
        if not MODIFY_FILES:
            print("      â„¹ï¸ None defined")
            return
        for path, content in MODIFY_FILES.items():
            full = os.path.join(ROOT, path)
            with open(full, "w", encoding="utf-8") as f:
                f.write(content)
            print(f"      âœï¸ Modified: {path}")
    except Exception as e:
        log_error("Step6", e)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
def main():
    start_time = datetime.now()
    
    print("\n" + "â•" * 50)
    print(f"ğŸ”§ BUILD V3.4 | {os.path.basename(ROOT)}")
    print(f"â° Started: {start_time.strftime('%H:%M:%S')}")
    print("â•" * 50)

    try:
        # â”€â”€â”€ Ù…Ø±Ø§Ø­Ù„ 1-6: Setup â”€â”€â”€
        step1_system()
        step2_venv()
        step3_deps()
        step4_folders()
        step5_new_files()
        step6_modify()

        # â”€â”€â”€ Ù…Ø±Ø­Ù„Ù‡ 7: Context â”€â”€â”€
        print("\n[7/9] ğŸ“‹ Context Generation...")
        try:
            context_gen.create_context_file()
            print("      âœ… Context created")
        except Exception as e:
            log_error("Step7-Context", e)

        # â”€â”€â”€ Ù…Ø±Ø­Ù„Ù‡ 8: Git â”€â”€â”€
        print("\n[8/9] ğŸ™ Git...")
        try:
            setup_git.setup()
            setup_git.sync(f"Build: {start_time.strftime('%Y-%m-%d %H:%M')}")
            print("      âœ… Git synced")
        except Exception as e:
            log_error("Step8-Git", e)

        # â”€â”€â”€ Ù…Ø±Ø­Ù„Ù‡ 9: Launch â”€â”€â”€
        print("\n[9/9] ğŸš€ Launch...")
        try:
            main_path = os.path.join(ROOT, MAIN_FILE)
            if os.path.exists(main_path):
                print("=" * 40)
                subprocess.run([VENV_PYTHON, main_path], cwd=ROOT)
            else:
                print(f"      â„¹ï¸ No {MAIN_FILE}")
        except Exception as e:
            log_error("Step9-Launch", e)

    except KeyboardInterrupt:
        print("\n\nâ›” Build cancelled by user")
        errors.append("KeyboardInterrupt")

    except Exception as e:
        print(f"\n\nğŸ’¥ Critical error: {e}")
        errors.append(f"Critical: {e}")

    finally:
        # â•â•â• Ù‡Ù…ÛŒØ´Ù‡ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯ â•â•â•
        end_time = datetime.now()
        duration = (end_time - start_time).seconds
        
        print("\n" + "â•" * 50)
        
        if errors:
            print(f"âš ï¸ BUILD COMPLETED WITH {len(errors)} ERROR(S)")
            print("â”€" * 50)
            for err in errors:
                print(f"   â€¢ {err}")
        else:
            print("âœ… BUILD COMPLETE â€” NO ERRORS")
        
        print("â”€" * 50)
        print(f"â±ï¸ Duration: {duration}s")
        print(f"ğŸ Finished: {end_time.strftime('%H:%M:%S')}")
        print("â•" * 50)

if __name__ == "__main__":
    main()




====================
File: modules\m_analysis.py
====================

def calculate_rsi(prices, period=14):
    """Calculates Relative Strength Index (RSI)"""
    if len(prices) < period + 1:
        return 50  # Not enough data
        
    gains = []
    losses = []
    
    # Calculate price changes
    for i in range(1, len(prices)):
        delta = prices[i] - prices[i-1]
        if delta > 0:
            gains.append(delta)
            losses.append(0)
        else:
            gains.append(0)
            losses.append(abs(delta))
            
    # Calculate initial average
    avg_gain = sum(gains[:period]) / period
    avg_loss = sum(losses[:period]) / period
    
    # Calculate smoothed averages
    for i in range(period, len(prices) - 1):
        avg_gain = (avg_gain * (period - 1) + gains[i]) / period
        avg_loss = (avg_loss * (period - 1) + losses[i]) / period
        
    if avg_loss == 0:
        return 100
        
    rs = avg_gain / avg_loss
    rsi = 100 - (100 / (1 + rs))
    return round(rsi, 2)

def analyze_market(symbol, candles):
    """Analyzes market data and returns a signal"""
    if not candles or len(candles) < 20:
        return {"signal": "WAIT", "rsi": 0, "price": 0}
        
    # Extract closing prices
    closes = [float(c['close']) for c in candles]
    current_price = closes[-1]
    
    # Calculate RSI
    rsi = calculate_rsi(closes)
    
    # Logic Strategy
    signal = "NEUTRAL âšª"
    if rsi < 30:
        signal = "BUY ğŸŸ¢ (Oversold)"
    elif rsi > 70:
        signal = "SELL ğŸ”´ (Overbought)"
        
    return {
        "symbol": symbol,
        "price": current_price,
        "rsi": rsi,
        "signal": signal
    }


====================
File: modules\m_data.py
====================
import requests
import os
import csv
import time
from datetime import datetime

# --- CONFIG ---
MEXC_BASE = "https://api.mexc.com"
PROXY_URL = "http://127.0.0.1:10809"
PROXIES = {"http": PROXY_URL, "https": PROXY_URL}

class DataEngine:
    def __init__(self, data_dir="data"):
        self.data_dir = data_dir
        if not os.path.exists(self.data_dir):
            os.makedirs(self.data_dir)
            
    def fetch_candles(self, symbol, interval="60m", limit=50):
        """
        Fetch OHLCV Data from MEXC
        Intervals: 1m, 5m, 15m, 30m, 60m, 4h, 1d, 1M
        """
        endpoint = "/api/v3/klines"
        params = {
            "symbol": symbol,
            "interval": interval,
            "limit": limit
        }
        
        try:
            print(f"   â¬‡ï¸ Fetching {symbol} ({interval})...")
            resp = requests.get(
                f"{MEXC_BASE}{endpoint}", 
                params=params, 
                proxies=PROXIES, 
                verify=False, 
                timeout=10
            )
            
            if resp.status_code == 200:
                data = resp.json()
                # MEXC Format: [Open Time, Open, High, Low, Close, Volume, Close Time, ...]
                processed_data = []
                for candle in data:
                    processed_data.append({
                        "timestamp": candle[0],
                        "datetime": datetime.fromtimestamp(candle[0]/1000).strftime('%Y-%m-%d %H:%M:%S'),
                        "open": candle[1],
                        "high": candle[2],
                        "low": candle[3],
                        "close": candle[4],
                        "volume": candle[5]
                    })
                return processed_data
            else:
                print(f"   âŒ API Error: {resp.status_code} - {resp.text}")
                return []
                
        except Exception as e:
            print(f"   âŒ Connection Error: {e}")
            return []

    def save_to_csv(self, symbol, data):
        if not data:
            return False
            
        filename = os.path.join(self.data_dir, f"{symbol}_history.csv")
        keys = data[0].keys()
        
        try:
            with open(filename, 'w', newline='', encoding='utf-8') as f:
                writer = csv.DictWriter(f, fieldnames=keys)
                writer.writeheader()
                writer.writerows(data)
            print(f"   ğŸ’¾ Saved to {filename} ({len(data)} rows)")
            return True
        except Exception as e:
            print(f"   âŒ Save Error: {e}")
            return False


====================
File: modules\m_trader.py
====================
import json
import os
from datetime import datetime

class PaperTrader:
    def __init__(self, initial_balance=1000):
        self.state_file = "data/paper_state.json"
        self.initial_balance = initial_balance
        self.load_state()

    def load_state(self):
        """Loads the simulated wallet state"""
        if os.path.exists(self.state_file):
            with open(self.state_file, 'r') as f:
                self.state = json.load(f)
        else:
            self.state = {
                "usdt_balance": self.initial_balance,
                "positions": {},  # Format: {"BTCUSDT": {"amount": 0.1, "entry_price": 50000}}
                "history": []
            }
            self.save_state()

    def save_state(self):
        """Saves current wallet state"""
        os.makedirs("data", exist_ok=True)
        with open(self.state_file, 'w') as f:
            json.dump(self.state, f, indent=4)

    def execute(self, symbol, signal, price):
        """Executes a paper trade based on signal"""
        if "BUY" in signal:
            return self.buy(symbol, price)
        elif "SELL" in signal:
            return self.sell(symbol, price)
        return None

    def buy(self, symbol, price):
        # Only buy if we have USDT and no current position for this symbol
        if self.state["usdt_balance"] > 10 and symbol not in self.state["positions"]:
            # Invest 20% of available balance per trade
            trade_amount_usdt = self.state["usdt_balance"] * 0.20
            amount_crypto = trade_amount_usdt / price
            
            # Update State
            self.state["usdt_balance"] -= trade_amount_usdt
            self.state["positions"][symbol] = {
                "amount": amount_crypto,
                "entry_price": price,
                "time": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }
            
            log = f"ğŸŸ¢ PAPER BUY: {symbol} @ ${price} (Amt: {amount_crypto:.6f})"
            self.state["history"].append(log)
            self.save_state()
            return log
        return None

    def sell(self, symbol, price):
        # Only sell if we have a position
        if symbol in self.state["positions"]:
            pos = self.state["positions"][symbol]
            amount = pos["amount"]
            revenue = amount * price
            profit = revenue - (amount * pos["entry_price"])
            
            # Update State
            self.state["usdt_balance"] += revenue
            del self.state["positions"][symbol]
            
            log = f"ğŸ”´ PAPER SELL: {symbol} @ ${price} | PnL: ${profit:.2f}"
            self.state["history"].append(log)
            self.save_state()
            return log
        return None
        
    def get_portfolio_value(self, current_prices):
        """Calculates total value (USDT + Assets)"""
        total = self.state["usdt_balance"]
        for sym, pos in self.state["positions"].items():
            current_price = current_prices.get(sym, pos["entry_price"])
            total += pos["amount"] * current_price
        return total


====================
File: modules\__init__.py
====================
# Ocean Hunter Modules


====================
File: modules\analysis\technical.py
====================
# modules/analysis/technical.py
def calculate_rsi(prices, period=14):
    if len(prices) < period + 1: return 50
    gains, losses = [], []
    for i in range(1, len(prices)):
        delta = prices[i] - prices[i-1]
        gains.append(max(delta, 0))
        losses.append(abs(min(delta, 0)))
    if not gains: return 50
    avg_gain = sum(gains[-period:]) / period
    avg_loss = sum(losses[-period:]) / period
    if avg_loss == 0: return 100
    rs = avg_gain / avg_loss
    return round(100 - (100 / (1 + rs)), 2)

def analyze_market(symbol, candles):
    if not candles: return {"signal": "NEUTRAL", "reason": "No Data", "price": 0, "rsi": 0}
    closes = [c['close'] for c in candles]
    rsi = calculate_rsi(closes)
    signal, reason = "NEUTRAL", f"RSI {rsi}"
    if rsi < 30: signal, reason = "BUY ğŸŸ¢", f"Oversold ({rsi})"
    elif rsi > 70: signal, reason = "SELL ğŸ”´", f"Overbought ({rsi})"
    return {"symbol": symbol, "price": closes[-1], "rsi": rsi, "signal": signal, "reason": reason}


====================
File: modules\analysis\__init__.py
====================
# Analysis Module


====================
File: modules\core\__init__.py
====================
# Core Module


====================
File: modules\network\dns_bypass.py
====================
# modules/network/dns_bypass.py
import socket
import requests
import json
import random

# --- STATIC FALLBACK IPS ---
# These are known Cloudflare IPs often used by Nobitex.
# Used ONLY if DoH fails.
STATIC_NOBITEX_IPS = [
    "104.26.13.16",
    "104.26.12.16",
    "172.67.70.166"
]

def resolve_doh_google(domain):
    """Resolve IP using Google DNS-over-HTTPS (Bypasses UDP blocks)"""
    try:
        print(f"   â˜ï¸  Requesting DoH from Google for {domain}...")
        url = f"https://dns.google/resolve?name={domain}&type=A"
        # We must disable proxy for the DNS lookup itself
        response = requests.get(url, timeout=5, proxies={"http": None, "https": None})
        
        if response.status_code == 200:
            data = response.json()
            if "Answer" in data:
                # Get the first A record
                for answer in data["Answer"]:
                    if answer["type"] == 1: # Type A
                        ip = answer["data"]
                        print(f"      âœ… DoH Success: {ip}")
                        return ip
    except Exception as e:
        print(f"      âš ï¸ DoH Failed: {e}")
    return None

def get_static_ip():
    """Return a random known IP for Nobitex"""
    ip = random.choice(STATIC_NOBITEX_IPS)
    print(f"   âš ï¸ Using Static Fallback IP: {ip}")
    return ip

# --- MONKEY PATCH ---
REAL_GETADDRINFO = socket.getaddrinfo
CACHED_IP = None

def patched_getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):
    global CACHED_IP
    
    if host == "api.nobitex.ir":
        print(f"   ğŸ›¡ï¸ Intercepted: {host}")
        
        if CACHED_IP:
            return [(socket.AF_INET, socket.SOCK_STREAM, 6, '', (CACHED_IP, port))]
            
        # 1. Try DoH (Best Method)
        resolved_ip = resolve_doh_google(host)
        
        # 2. Try Static Fallback (Last Resort)
        if not resolved_ip:
            resolved_ip = get_static_ip()
        
        if resolved_ip:
            print(f"   ğŸ’‰ Injecting: {resolved_ip}")
            CACHED_IP = resolved_ip
            return [(socket.AF_INET, socket.SOCK_STREAM, 6, '', (resolved_ip, port))]
        
    return REAL_GETADDRINFO(host, port, family, type, proto, flags)

def apply_patch():
    socket.getaddrinfo = patched_getaddrinfo


====================
File: modules\network\mexc_api.py
====================
"""
MEXC API Client â€” Raw Socket Implementation
For OCEAN HUNTER V10.8.2
Fixed: Content-Type header for authentication
"""

import socket
import ssl
import hmac
import hashlib
import time
import json
import os
import logging
from urllib.parse import urlencode
from dotenv import load_dotenv

load_dotenv()
logger = logging.getLogger("MEXC_API")


class MEXCClient:
    """MEXC Spot API via raw HTTPS socket"""

    def __init__(self):
        self.api_key = os.getenv("MEXC_API_KEY", "")
        self.api_secret = os.getenv("MEXC_SECRET_KEY", "")
        self.host = "api.mexc.com"
        self.base_path = "/api/v3"

    def _raw_request(self, method: str, path: str, params: dict = None, signed: bool = False) -> dict:
        """Send HTTPS request via raw socket"""
        params = params or {}

        if signed:
            params["timestamp"] = int(time.time() * 1000)
            query = urlencode(params)
            signature = hmac.new(
                self.api_secret.encode("utf-8"),
                query.encode("utf-8"),
                hashlib.sha256
            ).hexdigest()
            params["signature"] = signature

        query_string = urlencode(params) if params else ""

        if method == "GET":
            full_path = f"{self.base_path}{path}"
            if query_string:
                full_path += f"?{query_string}"
            body = ""
            content_type = "application/json"
        else:
            full_path = f"{self.base_path}{path}"
            body = query_string
            content_type = "application/x-www-form-urlencoded"

        headers = [
            f"{method} {full_path} HTTP/1.1",
            f"Host: {self.host}",
            f"X-MEXC-APIKEY: {self.api_key}",
            f"Content-Type: {content_type}",
            "Connection: close",
        ]

        if body:
            headers.append(f"Content-Length: {len(body)}")

        request = "\r\n".join(headers) + "\r\n\r\n"
        if body:
            request += body

        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.host, 443), timeout=15) as sock:
                with context.wrap_socket(sock, server_hostname=self.host) as ssock:
                    ssock.sendall(request.encode("utf-8"))
                    response = b""
                    while True:
                        chunk = ssock.recv(4096)
                        if not chunk:
                            break
                        response += chunk

            response_text = response.decode("utf-8", errors="ignore")

            if "\r\n\r\n" in response_text:
                _, body_text = response_text.split("\r\n\r\n", 1)
            else:
                body_text = response_text

            if body_text.startswith("{") or body_text.startswith("["):
                return json.loads(body_text)
            else:
                lines = body_text.split("\r\n")
                for line in lines:
                    line = line.strip()
                    if line.startswith("{") or line.startswith("["):
                        return json.loads(line)
            return {"raw": body_text}

        except json.JSONDecodeError as e:
            logger.error(f"JSON parse error: {e}")
            return {"error": str(e)}
        except Exception as e:
            logger.error(f"Request failed: {e}")
            return {"error": str(e)}

    def ping(self) -> dict:
        return self._raw_request("GET", "/ping")

    def get_server_time(self) -> dict:
        return self._raw_request("GET", "/time")

    def get_ticker_price(self, symbol: str = "BTCUSDT") -> dict:
        return self._raw_request("GET", "/ticker/price", {"symbol": symbol})

    def get_orderbook(self, symbol: str, limit: int = 20) -> dict:
        return self._raw_request("GET", "/depth", {"symbol": symbol, "limit": limit})

    def get_account(self) -> dict:
        return self._raw_request("GET", "/account", signed=True)

    def get_balance(self, asset: str = None) -> dict:
        account = self.get_account()
        if "error" in account:
            return account
        balances = account.get("balances", [])
        if asset:
            for b in balances:
                if b.get("asset") == asset:
                    return b
            return {"asset": asset, "free": "0", "locked": "0"}
        return {"balances": balances}

    def create_order(self, symbol: str, side: str, order_type: str,
                     quantity: float, price: float = None) -> dict:
        params = {
            "symbol": symbol,
            "side": side.upper(),
            "type": order_type.upper(),
            "quantity": str(quantity),
        }
        if price and order_type.upper() == "LIMIT":
            params["price"] = str(price)
        return self._raw_request("POST", "/order", params, signed=True)

    def cancel_order(self, symbol: str, order_id: str = None) -> dict:
        params = {"symbol": symbol}
        if order_id:
            params["orderId"] = order_id
        return self._raw_request("DELETE", "/order", params, signed=True)

    def get_open_orders(self, symbol: str = None) -> dict:
        params = {"symbol": symbol} if symbol else {}
        return self._raw_request("GET", "/openOrders", params, signed=True)


_client_instance = None

def get_client() -> MEXCClient:
    global _client_instance
    if _client_instance is None:
        _client_instance = MEXCClient()
    return _client_instance


====================
File: modules\network\nobitex_api.py
====================
# modules/network/nobitex_api.py
import requests
import urllib3
import sys
import os

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Apply Patch
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
try:
    from modules.network.dns_bypass import apply_patch
    apply_patch()
    print("âœ… DoH DNS Engine Activated")
except ImportError as e:
    print(f"âš ï¸ Could not load DNS Bypass: {e}")

class NobitexAPI:
    BASE_URL = "https://api.nobitex.ir"

    def __init__(self):
        self.session = requests.Session()
        # CRITICAL: Disable proxies for the main connection too
        self.session.trust_env = False 
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Chrome/120.0.0.0 Safari/537.36",
            "Accept": "application/json"
        })

    def get_ohlcv(self, symbol, resolution="60", from_ts=None, to_ts=None):
        url = f"{self.BASE_URL}/market/udf/history"
        params = {"symbol": symbol, "resolution": resolution, "from": from_ts, "to": to_ts}
        
        try:
            print(f"   ğŸ“¡ Connecting to {url} ...")
            # verify=False is needed because we might be using a direct IP which doesn't match the SSL cert
            response = self.session.get(url, params=params, timeout=20, verify=False)
            
            if response.status_code == 200:
                data = response.json()
                if data.get("s") == "ok":
                    return data
                else:
                    return {"s": "error", "msg": f"API Error: {data.get('s')}"}
            else:
                return {"s": "error", "msg": f"HTTP {response.status_code}"}
                
        except Exception as e:
            return {"s": "error", "msg": f"{type(e).__name__}: {str(e)}"}


====================
File: modules\network\rate_limiter.py
====================
import time
import logging
from collections import deque

logger = logging.getLogger("RateLimiter")

class RateLimiter:
    def __init__(self, max_calls=25, period=60):
        self.max_calls = max_calls
        self.period = period
        self.timestamps = deque()

    def wait_if_needed(self):
        now = time.time()
        while self.timestamps and self.timestamps[0] <= now - self.period:
            self.timestamps.popleft()

        if len(self.timestamps) >= self.max_calls:
            sleep_time = self.timestamps[0] + self.period - now + 0.1
            if sleep_time > 0:
                time.sleep(sleep_time)
            self.wait_if_needed()
        
        self.timestamps.append(time.time())

====================
File: modules\network\telegram_bot.py
====================
"""
Telegram Bot â€” SOCKS5 Proxy Support
For OCEAN HUNTER V10.8.2
"""

import socket
import ssl
import json
import os
import logging
from urllib.parse import quote
from dotenv import load_dotenv

load_dotenv()
logger = logging.getLogger("TELEGRAM")


class TelegramBot:
    """Telegram Bot via SOCKS5 proxy (Raw Socket)"""

    def __init__(self):
        self.token = os.getenv("TELEGRAM_BOT_TOKEN", "")
        self.chat_id = os.getenv("TELEGRAM_CHAT_ID", "")
        self.proxy_host = os.getenv("PROXY_HOST", "127.0.0.1")
        self.proxy_port = int(os.getenv("PROXY_PORT", "1080"))
        self.use_proxy = os.getenv("USE_PROXY", "true").lower() == "true"
        self.api_host = "api.telegram.org"

    def _socks5_connect(self, target_host: str, target_port: int) -> socket.socket:
        """Connect via SOCKS5 proxy"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(15)
        sock.connect((self.proxy_host, self.proxy_port))

        sock.sendall(b"\x05\x01\x00")
        resp = sock.recv(2)
        if resp != b"\x05\x00":
            raise Exception(f"SOCKS5 handshake failed: {resp.hex()}")

        req = b"\x05\x01\x00\x03"
        req += bytes([len(target_host)]) + target_host.encode()
        req += target_port.to_bytes(2, "big")
        sock.sendall(req)

        resp = sock.recv(10)
        if resp[1] != 0:
            raise Exception(f"SOCKS5 connect failed: code {resp[1]}")

        return sock

    def _direct_connect(self, target_host: str, target_port: int) -> socket.socket:
        """Direct connection without proxy"""
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(15)
        sock.connect((target_host, target_port))
        return sock

    def _request(self, method: str, params: dict = None) -> dict:
        """Send request to Telegram API"""
        params = params or {}
        path = f"/bot{self.token}/{method}"

        if params:
            query = "&".join(f"{k}={quote(str(v))}" for k, v in params.items())
            path = f"{path}?{query}"

        request = f"GET {path} HTTP/1.1\r\n"
        request += f"Host: {self.api_host}\r\n"
        request += "Connection: close\r\n\r\n"

        try:
            if self.use_proxy:
                sock = self._socks5_connect(self.api_host, 443)
            else:
                sock = self._direct_connect(self.api_host, 443)

            context = ssl.create_default_context()
            with context.wrap_socket(sock, server_hostname=self.api_host) as ssock:
                ssock.sendall(request.encode())
                response = b""
                while True:
                    chunk = ssock.recv(4096)
                    if not chunk:
                        break
                    response += chunk

            text = response.decode("utf-8", errors="ignore")
            if "\r\n\r\n" in text:
                _, body = text.split("\r\n\r\n", 1)
            else:
                body = text

            for line in body.split("\r\n"):
                line = line.strip()
                if line.startswith("{"):
                    return json.loads(line)

            if body.strip().startswith("{"):
                return json.loads(body.strip())

            return {"ok": False, "raw": body[:200]}

        except Exception as e:
            logger.error(f"Telegram request failed: {e}")
            return {"ok": False, "error": str(e)}

    def send_message(self, text: str, chat_id: str = None) -> dict:
        """Send a text message"""
        return self._request("sendMessage", {
            "chat_id": chat_id or self.chat_id,
            "text": text,
            "parse_mode": "HTML"
        })

    def send_alert(self, level: str, message: str) -> dict:
        """Send formatted alert"""
        emojis = {"INFO": "â„¹ï¸", "WARNING": "âš ï¸", "CRITICAL": "ğŸš¨", "SUCCESS": "âœ…"}
        emoji = emojis.get(level.upper(), "ğŸ“Œ")
        text = f"{emoji} <b>{level.upper()}</b>\n{message}"
        return self.send_message(text)

    def test_connection(self) -> bool:
        """Test if bot can connect"""
        result = self._request("getMe")
        return result.get("ok", False)


_bot_instance = None

def get_bot() -> TelegramBot:
    global _bot_instance
    if _bot_instance is None:
        _bot_instance = TelegramBot()
    return _bot_instance

def send_telegram(message: str, level: str = "INFO") -> bool:
    """Quick send function"""
    bot = get_bot()
    result = bot.send_alert(level, message)
    return result.get("ok", False)


====================
File: modules\network\telegram_client.py
====================

import os
import requests
from dotenv import load_dotenv

# Ensure env is loaded
load_dotenv(os.path.join(os.path.dirname(os.path.dirname(os.path.dirname(__file__))), '.env'))

class TelegramBot:
    def __init__(self):
        self.token = os.getenv("TELEGRAM_BOT_TOKEN")
        self.chat_id = os.getenv("TELEGRAM_CHAT_ID")
        self.base_url = f"https://api.telegram.org/bot{self.token}/sendMessage"

    def send_message(self, message):
        if not self.token or not self.chat_id:
            print(f"ğŸ”• Telegram Auth Missing (Check .env).")
            return False

        payload = {
            "chat_id": self.chat_id,
            "text": message,
            "parse_mode": "HTML"
        }
        
        try:
            # Using verify=False to avoid SSL issues on some local proxies, can be removed in prod
            response = requests.post(self.base_url, json=payload, timeout=10)
            if response.status_code == 200:
                return True
            else:
                print(f"âŒ TG Error {response.status_code}: {response.text}")
                return False
        except Exception as e:
            print(f"âŒ TG Connection Error: {e}")
            return False


====================
File: modules\network\__init__.py
====================
from .mexc_api import MEXCClient
from .telegram_bot import TelegramBot

def get_client():
    return MEXCClient()


====================
File: modules\security\__init__.py
====================
# Security Module


====================
File: modules\strategy\__init__.py
====================
# Strategy Module


====================
File: modules\telegram\__init__.py
====================
# Telegram Module


====================
File: modules\trading\__init__.py
====================
# Trading Module


====================
File: modules\watchdog\__init__.py
====================
# Watchdog Module


====================
File: tests\__init__.py
====================


====================
File: tests\core\data_engine.py
====================

import pandas as pd
import logging
from .interfaces import IDataProvider

logger = logging.getLogger("DataEngine")

class CsvCandlePlayer(IDataProvider):
    """
    Reads historical data from CSV and serves it candle by candle.
    Compatible with:
    1. Generated Test Data (timestamp, open, high...)
    2. Binance/MEXC Export (Open time, Open, High...)
    """
    def __init__(self, csv_path):
        self.csv_path = csv_path
        self.data = pd.DataFrame()
        self.current_index = 0
        self._load_data()

    def _load_data(self):
        try:
            df = pd.read_csv(self.csv_path)
            
            # 1. Normalize Column Names (Lowercase & Strip)
            df.columns = [c.lower().strip() for c in df.columns]
            
            # 2. Map Standard Names
            rename_map = {
                'open time': 'timestamp',
                'time': 'timestamp',
                'date': 'timestamp',
                'vol': 'volume'
            }
            df.rename(columns=rename_map, inplace=True)
            
            # 3. Validate Required Columns
            required = {'timestamp', 'open', 'high', 'low', 'close', 'volume'}
            if not required.issubset(df.columns):
                missing = required - set(df.columns)
                raise ValueError(f"CSV missing columns: {missing}. Found: {list(df.columns)}")
                
            # 4. Sort by time
            df.sort_values('timestamp', inplace=True)
            df.reset_index(drop=True, inplace=True)
            
            self.data = df
            logger.info(f"Loaded {len(df)} candles from {self.csv_path}")
            
        except Exception as e:
            logger.error(f"Failed to load CSV: {e}")
            raise

    def get_next_candle(self):
        if self.current_index < len(self.data):
            # Convert row to dict
            candle = self.data.iloc[self.current_index].to_dict()
            self.current_index += 1
            return candle
        return None

    def get_server_time(self):
        # Return time of current candle (Simulation Time)
        if self.current_index > 0:
            return self.data.iloc[self.current_index - 1]['timestamp']
        return 0


====================
File: tests\core\interfaces.py
====================

from abc import ABC, abstractmethod
from typing import Dict, Any

class IDataProvider(ABC):
    """Interface for fetching market data (Live or Backtest)."""
    
    @abstractmethod
    def get_next_candle(self) -> Dict[str, Any]:
        """Returns the next candle or None if EOF."""
        pass

    @abstractmethod
    def get_server_time(self) -> int:
        """Returns current simulated or real server time (ms)."""
        pass

class IExecutionEngine(ABC):
    """Interface for executing orders."""
    pass


====================
File: tests\core\simulator.py
====================

import logging
from .interfaces import IDataProvider
from .virtual_wallet import VirtualWallet

logger = logging.getLogger("Simulator")

class MarketSimulator:
    """
    The Brain of the Test.
    Connects DataProvider (Market) -> VirtualWallet (Account).
    """
    def __init__(self, wallet: VirtualWallet, data_provider: IDataProvider):
        self.wallet = wallet
        self.data_provider = data_provider
        self.current_candle = None
        self.steps_count = 0

    def run_step(self):
        """Advances the simulation by one candle."""
        candle = self.data_provider.get_next_candle()
        
        if not candle:
            return False # End of Data

        self.current_candle = candle
        self.steps_count += 1
        return True

    def execute_trade(self, symbol: str, side: str, quantity: float):
        """Manually execute a trade at the CURRENT candle's closing price."""
        if not self.current_candle:
            raise Exception("Market not started yet. Call run_step() first.")
            
        price = self.current_candle['close']
        cost = price * quantity
        fee = cost * self.wallet.commission_rate
        
        if side.upper() == "BUY":
            usdt_bal = self.wallet.get_balance("USDT")
            total_cost = cost + fee
            
            if usdt_bal >= total_cost:
                self.wallet.balances["USDT"] = usdt_bal - total_cost
                current_asset = self.wallet.get_balance(symbol)
                self.wallet.balances[symbol] = current_asset + quantity
                logger.info(f"ğŸ‘‰ EXECUTED BUY {quantity} {symbol} @ ${price}")
            else:
                logger.error("Insufficient USDT for BUY")

        elif side.upper() == "SELL":
            asset_bal = self.wallet.get_balance(symbol)
            if asset_bal >= quantity:
                self.wallet.balances[symbol] = asset_bal - quantity
                proceeds = cost - fee
                current_usdt = self.wallet.get_balance("USDT")
                self.wallet.balances["USDT"] = current_usdt + proceeds
                logger.info(f"ğŸ‘‰ EXECUTED SELL {quantity} {symbol} @ ${price}")
            else:
                logger.error(f"Insufficient {symbol} for SELL")

    def get_market_price(self):
        return self.current_candle['close'] if self.current_candle else 0


====================
File: tests\core\test_provider.py
====================

import logging
from .simulator import MarketSimulator

logger = logging.getLogger("TestProvider")

class TestSimulatorProvider:
    """
    A wrapper around MarketSimulator that mimics a Real Exchange Provider.
    Strategies will interact with THIS class, not the Simulator directly.
    """
    def __init__(self, simulator: MarketSimulator):
        self.sim = simulator

    # --- Market Data Methods ---
    def get_ticker_price(self, symbol: str) -> float:
        """Returns the current price from the simulator."""
        return self.sim.get_market_price()

    def get_server_time(self):
        """Returns the simulated time."""
        if self.sim.current_candle:
            return self.sim.current_candle.get('timestamp')
        return 0

    # --- Account Methods ---
    def get_balance(self, asset: str) -> float:
        """Returns balance from the Virtual Wallet."""
        return self.sim.wallet.get_balance(asset)

    def get_all_balances(self) -> dict:
        return self.sim.wallet.balances

    # --- Trading Methods ---
    def create_order(self, symbol: str, side: str, order_type: str, quantity: float, price: float = None):
        """
        Mimics creating an order on an exchange.
        Currently supports 'MARKET' orders mainly.
        """
        # For simulation simplicity in Phase 4, we treat LIMIT as MARKET execution at current price
        # (A real backtester would check if Low <= Price <= High)
        
        # Validations
        current_price = self.get_ticker_price(symbol)
        if current_price <= 0:
            logger.error("âŒ Cannot place order: Market price is 0 (Simulation not started?)")
            return None

        logger.info(f"âš¡ Requesting Order: {side} {quantity} {symbol} (Type: {order_type})")
        
        try:
            # Delegate execution to the Simulator Core
            self.sim.execute_trade(symbol, side, quantity)
            
            # Return a fake order structure (like CCXT/Exchange API returns)
            return {
                "symbol": symbol,
                "id": f"sim-order-{self.sim.steps_count}",
                "side": side,
                "amount": quantity,
                "price": current_price,
                "status": "closed", # Instant execution
                "filled": quantity
            }
        except Exception as e:
            logger.error(f"âŒ Order Failed: {e}")
            return None


====================
File: tests\core\virtual_wallet.py
====================

import logging
from typing import Dict, Optional

# Configure logging
logger = logging.getLogger("VirtualWallet")

class VirtualWallet:
    """
    Simulates a crypto exchange wallet with locking mechanism and fees.
    
    EXCHANGE: MEXC Global
    FEE STRUCTURE: 0.1% (0.001) for Maker/Taker (Standard Spot)
    """
    
    def __init__(self, initial_balances: Dict[str, float] = None, commission_rate: float = 0.001):
        # Default commission_rate set to 0.001 (0.1%) for MEXC
        self.balances = initial_balances if initial_balances else {}  # Available funds
        self.locked = {}  # Funds locked in open orders
        self.commission_rate = commission_rate
        self.history = [] # Transaction history log

    def get_balance(self, asset: str) -> float:
        """Returns AVAILABLE balance (not including locked)."""
        return self.balances.get(asset, 0.0)

    def get_total_balance(self, asset: str) -> float:
        """Returns Total balance (Available + Locked)."""
        return self.balances.get(asset, 0.0) + self.locked.get(asset, 0.0)

    def lock_funds(self, asset: str, amount: float) -> bool:
        """Locks funds for an order. Returns True if successful."""
        if amount <= 0:
            return False
            
        available = self.balances.get(asset, 0.0)
        # Using a small epsilon for float comparison safety
        if available >= amount:
            self.balances[asset] = available - amount
            self.locked[asset] = self.locked.get(asset, 0.0) + amount
            return True
        else:
            logger.warning(f"Insufficient funds to lock {amount} {asset}. Available: {available}")
            return False

    def unlock_funds(self, asset: str, amount: float):
        """Unlocks funds (e.g., cancelled order)."""
        locked_amount = self.locked.get(asset, 0.0)
        if locked_amount >= amount:
            self.locked[asset] = locked_amount - amount
            self.balances[asset] = self.balances.get(asset, 0.0) + amount
        else:
            logger.error(f"Attempted to unlock {amount} {asset} but only {locked_amount} is locked.")
            # Recover as much as possible
            self.balances[asset] = self.balances.get(asset, 0.0) + locked_amount
            self.locked[asset] = 0

    def apply_trade(self, side: str, base_asset: str, quote_asset: str, 
                   amount: float, price: float, is_maker: bool = False):
        """
        Executes a trade and updates balances.
        side: 'BUY' or 'SELL'
        amount: Amount of Base Asset (e.g., BTC)
        price: Price in Quote Asset (e.g., USDT)
        """
        cost = amount * price
        fee_rate = self.commission_rate 
        
        if side == 'BUY':
            # Buyer pays Quote (USDT), receives Base (BTC)
            # Funds were already locked in Quote (USDT)
            
            # 1. Deduct cost from locked Quote
            current_locked = self.locked.get(quote_asset, 0.0)
            if current_locked >= cost:
                self.locked[quote_asset] = current_locked - cost
            else:
                # Fallback correction
                remaining = cost - current_locked
                if self.balances.get(quote_asset, 0) >= remaining:
                    self.balances[quote_asset] -= remaining
                self.locked[quote_asset] = 0
                
            # 2. Add Base (BTC) - Fee is deducted from received asset on MEXC
            gross_receive = amount
            fee = gross_receive * fee_rate
            net_receive = gross_receive - fee
            
            self.balances[base_asset] = self.balances.get(base_asset, 0.0) + net_receive
            
            self._log_trade(side, base_asset, quote_asset, amount, price, fee, fee_asset=base_asset)
            
        elif side == 'SELL':
            # Seller pays Base (BTC), receives Quote (USDT)
            # Funds (BTC) were locked
            
            # 1. Deduct Base from locked
            current_locked = self.locked.get(base_asset, 0.0)
            if current_locked >= amount:
                self.locked[base_asset] = current_locked - amount
            else:
                 remaining = amount - current_locked
                 if self.balances.get(base_asset, 0) >= remaining:
                     self.balances[base_asset] -= remaining
                 self.locked[base_asset] = 0
                 
            # 2. Add Quote (USDT) - Fee deducted from USDT received
            gross_receive = cost
            fee = gross_receive * fee_rate
            net_receive = gross_receive - fee
            
            self.balances[quote_asset] = self.balances.get(quote_asset, 0.0) + net_receive
            
            self._log_trade(side, base_asset, quote_asset, amount, price, fee, fee_asset=quote_asset)

    def _log_trade(self, side, base, quote, amount, price, fee, fee_asset):
        self.history.append({
            "side": side,
            "pair": f"{base}{quote}",
            "amount": amount,
            "price": price,
            "fee": fee,
            "fee_asset": fee_asset,
            "timestamp": "SIMULATED" 
        })


====================
File: tests\core\__init__.py
====================


====================
File: tests\providers\__init__.py
====================


====================
File: tests\reporters\__init__.py
====================


====================
File: tests\runners\backtest_runner.py
====================

import logging
import time
from tests.core.virtual_wallet import VirtualWallet
from tests.core.data_engine import CsvCandlePlayer
from tests.core.simulator import MarketSimulator
from tests.core.test_provider import TestSimulatorProvider

logger = logging.getLogger("BacktestRunner")

class BacktestRunner:
    """
    Orchestrates the entire backtest process:
    1. Sets up Wallet, Data, Simulator, Provider.
    2. Initializes the Strategy with the Provider.
    3. Runs the simulation loop.
    4. Generates a Performance Report.
    """
    def __init__(self, csv_path, initial_capital=1000.0, symbol="SOL"):
        self.symbol = symbol
        self.initial_capital = initial_capital
        
        # Core Components
        self.wallet = VirtualWallet(initial_balances={"USDT": initial_capital})
        self.data_engine = CsvCandlePlayer(csv_path)
        self.simulator = MarketSimulator(self.wallet, self.data_engine)
        self.provider = TestSimulatorProvider(self.simulator)
        
        # Stats
        self.trades = []
        self.start_time = time.time()

    def run(self, strategy_class):
        """
        Runs the backtest using the given Strategy Class.
        strategy_class: A class that accepts (provider, symbol) and has on_candle() method.
        """
        print(f"ğŸš€ Starting Backtest on {self.symbol}...")
        
        # Initialize Strategy
        strategy = strategy_class(self.provider, self.symbol)
        
        steps = 0
        while self.simulator.run_step():
            # Get current candle data
            candle = self.simulator.current_candle
            
            # Tick the strategy
            strategy.on_candle(candle)
            steps += 1
            
            if steps % 100 == 0:
                print(f"   â³ Processed {steps} candles...", end='\r')

        print(f"\nâœ… Backtest Complete. Processed {steps} candles.")
        return self._generate_report()

    def _generate_report(self):
        """Calculates basic performance metrics."""
        final_balance = self.wallet.get_balance("USDT")
        
        # Calculate Asset Value (sell everything at last price)
        last_price = self.simulator.get_market_price()
        asset_qty = self.wallet.get_balance(self.symbol)
        asset_value = asset_qty * last_price
        
        total_equity = final_balance + asset_value
        pnl = total_equity - self.initial_capital
        roi = (pnl / self.initial_capital) * 100
        
        report = {
            "initial_capital": self.initial_capital,
            "final_equity": total_equity,
            "pnl": pnl,
            "roi": roi,
            "symbol": self.symbol,
            "simulated_trades": len(self.provider.orders) if hasattr(self.provider, 'orders') else "N/A"
        }
        return report


====================
File: tests\runners\__init__.py
====================


====================
File: tests\strategies\smart_sniper.py
====================

import pandas as pd
import numpy as np
import logging

class SmartSniperStrategy:
    """
    ğŸŒŠ Ocean Hunter Strategy: Smart Sniper V10.8.2
    
    Logic:
    1. Indicators: RSI(14), MACD(12,26,9), Bollinger Bands(20, 2std)
    2. Entry: Score-based system (RSI Dip + BB Touch + MACD Histogram)
    3. Exit: Fixed TP/SL or RSI Overbought
    """
    def __init__(self, provider, symbol, risk_per_trade=0.98):
        self.provider = provider
        self.symbol = symbol
        self.risk_per_trade = risk_per_trade # Use 98% of available balance
        
        # History Buffer for Calculation
        self.history = []
        self.warmup_period = 35 # Min candles needed for MACD/RSI
        
        # Position Management
        self.position_size = 0.0
        self.entry_price = 0.0
        
        # Risk Settings
        self.tp_percent = 0.015  # 1.5% Target
        self.sl_percent = 0.010  # 1.0% Stop Loss

    def _calculate_indicators(self, df):
        """Calculates Technical Indicators on the DataFrame"""
        # RSI
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        
        # Bollinger Bands
        df['bb_mid'] = df['close'].rolling(window=20).mean()
        df['bb_std'] = df['close'].rolling(window=20).std()
        df['bb_upper'] = df['bb_mid'] + (df['bb_std'] * 2)
        df['bb_lower'] = df['bb_mid'] - (df['bb_std'] * 2)
        
        # MACD
        exp12 = df['close'].ewm(span=12, adjust=False).mean()
        exp26 = df['close'].ewm(span=26, adjust=False).mean()
        df['macd'] = exp12 - exp26
        df['signal'] = df['macd'].ewm(span=9, adjust=False).mean()
        
        return df.iloc[-1] # Return only the latest row

    def on_candle(self, candle):
        """Main Logic Loop called on every new candle"""
        # 1. Update History
        self.history.append({
            'open': candle['open'],
            'high': candle['high'],
            'low': candle['low'],
            'close': candle['close'],
            'volume': candle['volume']
        })
        
        # Keep history manageable (last 100 candles is enough)
        if len(self.history) > 100:
            self.history.pop(0)
            
        # 2. Warmup Check
        if len(self.history) < self.warmup_period:
            return

        # 3. Calculate Indicators
        df = pd.DataFrame(self.history)
        latest = self._calculate_indicators(df)
        
        current_price = latest['close']
        rsi = latest['rsi']
        
        # 4. Check Exit Conditions (If we have a position)
        if self.position_size > 0:
            self._check_exit(current_price, rsi)
            return

        # 5. Check Entry Conditions (If we have NO position)
        self._check_entry(latest)

    def _check_entry(self, latest):
        score = 0
        price = latest['close']
        
        # â”€â”€â”€ SCORING SYSTEM â”€â”€â”€
        
        # A. RSI Condition (Oversold)
        if latest['rsi'] < 30:
            score += 40
        elif latest['rsi'] < 40:
            score += 20
            
        # B. Bollinger Band Condition (Dip)
        if price <= latest['bb_lower']:
            score += 30 # Strong Signal: Touching Lower Band
        elif price <= (latest['bb_lower'] * 1.005):
            score += 10 # Near Lower Band
            
        # C. MACD Condition (Momentum)
        if latest['macd'] > latest['signal']:
            score += 10 # Bullish Momentum

        # â”€â”€â”€ EXECUTION â”€â”€â”€
        THRESHOLD = 50 
        
        if score >= THRESHOLD:
            balance = self.provider.get_balance("USDT")
            if balance > 10:
                amount_to_spend = balance * self.risk_per_trade
                qty = amount_to_spend / price
                
                print(f"   âš¡ SIGNAL FIRED (Score: {score}) | RSI: {latest['rsi']:.1f} | Price: {price:.2f}")
                self.provider.create_order(self.symbol, "BUY", "MARKET", qty)
                
                self.position_size = qty
                self.entry_price = price

    def _check_exit(self, current_price, rsi):
        # Calculate PnL %
        pnl_pct = (current_price - self.entry_price) / self.entry_price
        
        exit_reason = None
        
        # 1. Take Profit
        if pnl_pct >= self.tp_percent:
            exit_reason = "âœ… TP Hit"
            
        # 2. Stop Loss
        elif pnl_pct <= -self.sl_percent:
            exit_reason = "âŒ SL Hit"
            
        # 3. RSI Overbought (Sniper Exit)
        elif rsi > 70 and pnl_pct > 0.005: # Only exit on RSI if in profit
            exit_reason = "âš ï¸ RSI Overbought"

        if exit_reason:
            print(f"   ğŸ”„ EXITING: {exit_reason} | PnL: {pnl_pct*100:.2f}%")
            self.provider.create_order(self.symbol, "SELL", "MARKET", self.position_size)
            self.position_size = 0.0
            self.entry_price = 0.0


====================
File: tools\check_live_connection.py
====================

import os
import sys
import time
import hmac
import hashlib
import requests
import json
from datetime import datetime
from dotenv import load_dotenv

# Add Root to path
sys.path.append(os.getcwd())

# Load Env
load_dotenv()

# Configuration
API_KEY = os.getenv("MEXC_API_KEY")
SECRET_KEY = os.getenv("MEXC_SECRET_KEY")
BASE_URL = "https://api.mexc.com"

# Telegram Config
TG_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TG_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

def send_telegram(msg):
    if not TG_TOKEN or not TG_CHAT_ID: return
    try:
        url = f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage"
        payload = {"chat_id": TG_CHAT_ID, "text": msg, "parse_mode": "HTML"}
        requests.post(url, json=payload, timeout=5)
    except: pass

def get_signature(params):
    query_string = "&".join([f"{k}={v}" for k, v in sorted(params.items())])
    return hmac.new(SECRET_KEY.encode('utf-8'), query_string.encode('utf-8'), hashlib.sha256).hexdigest()

def check_connection():
    print("ğŸ”Œ Initiating LIVE Connection to MEXC Global...")
    
    if not API_KEY or "CHANGE_ME" in API_KEY or len(API_KEY) < 10:
        print("âŒ ERROR: API_KEY is invalid or not set in .env")
        print("ğŸ‘‰ Please open .env file and paste your MEXC API Keys.")
        sys.exit(1)

    headers = {
        "X-MEXC-APIKEY": API_KEY,
        "Content-Type": "application/json"
    }

    # 1. Check Server Time (Public Endpoint)
    try:
        resp = requests.get(f"{BASE_URL}/api/v3/time", timeout=10)
        server_time = resp.json()['serverTime']
        print(f"âœ… Public API OK. Server Time: {server_time}")
    except Exception as e:
        print(f"âŒ Public API Connection Failed: {e}")
        print("ğŸ‘‰ Check your VPN/Internet connection.")
        sys.exit(1)

    # 2. Check Account Balance (Private Endpoint - Signature Required)
    timestamp = int(time.time() * 1000)
    params = {"timestamp": timestamp}
    params["signature"] = get_signature(params)
    
    print("ğŸ”‘ Authenticating...")
    try:
        resp = requests.get(f"{BASE_URL}/api/v3/account", headers=headers, params=params, timeout=10)
        
        if resp.status_code == 200:
            data = resp.json()
            balances = [b for b in data['balances'] if float(b['free']) > 0 or float(b['locked']) > 0]
            
            print(f"âœ… AUTHENTICATION SUCCESSFUL!")
            print(f"ğŸ’° Account Type: {data['accountType']}")
            
            balance_str = ""
            if balances:
                print("ğŸ’¼ WALLET CONTENTS:")
                for b in balances:
                    print(f"   - {b['asset']}: {b['free']} (Locked: {b['locked']})")
                    # Double escape needed for file generation
                    balance_str += f"ğŸ”¹ <b>{b['asset']}</b>: <code>{b['free']}</code>\n"
            else:
                print("   (Wallet is Empty)")
                balance_str = "ğŸ”¹ Wallet is Empty (0.00)\n"

            # Success Message
            msg = (
                "ğŸš€ <b>Ocean Hunter: LIVE SYSTEM ONLINE</b>\n\n"
                "âœ… <b>Connection Established</b>\n"
                "ğŸ¦ Exchange: <code>MEXC Global</code>\n"
                f"{balance_str}\n"
                "ğŸ¤– <i>Ready for Real Trading.</i>"
            )
            send_telegram(msg)
            return True
            
        else:
            print(f"âŒ AUTH FAILED: HTTP {resp.status_code}")
            print(f"âš ï¸ Response: {resp.text}")
            return False

    except Exception as e:
        print(f"âŒ Critical Error during Auth: {e}")
        return False

if __name__ == "__main__":
    success = check_connection()
    if not success:
        sys.exit(1)


====================
File: tools\gen_scenario.py
====================

import pandas as pd
import numpy as np
import os

def create_winning_scenario():
    print("ğŸ¨ Generating Synthetic 'Perfect Setup' Data...")
    
    # 1. Create a baseline
    length = 300
    # FIX: Use '15min' instead of '15T' to avoid FutureWarning
    dates = pd.date_range(start='2024-01-01', periods=length, freq='15min') 
    
    # 2. Pattern: Stable -> Crash (Buy) -> Pump (Sell) -> Stable
    prices = []
    base_price = 100.0
    
    for i in range(length):
        if i < 50: 
            # Stable
            price = base_price + np.random.normal(0, 0.2)
        elif 50 <= i < 70:
            # CRASH (Trigger RSI < 30)
            base_price -= 1.5 # Fast drop
            price = base_price
        elif 70 <= i < 100:
            # Bottom Consolidation
            price = base_price + np.random.normal(0, 0.5)
        elif 100 <= i < 130:
            # PUMP (Trigger Sell)
            base_price += 1.5 # Fast pump
            price = base_price
        else:
            # Stable again
            price = base_price + np.random.normal(0, 0.2)
            
        prices.append(price)

    # 3. Create DataFrame
    # FIX: Column MUST be named 'timestamp' and be Unix/Int format for DataEngine compatibility
    df = pd.DataFrame({
        'timestamp': dates.astype('int64') // 10**9, 
        'open': prices,
        'high': [p + 0.5 for p in prices],
        'low': [p - 0.5 for p in prices],
        'close': prices,
        'volume': [1000 + np.random.randint(0, 500) for _ in range(length)]
    })
    
    # Save
    os.makedirs("tests/data/scenarios", exist_ok=True)
    path = "tests/data/scenarios/SCENARIO_WIN.csv"
    df.to_csv(path, index=False)
    print(f"âœ… Created: {path}")
    return path

if __name__ == "__main__":
    create_winning_scenario()

